<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title> | Rick2pc</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Rick2pc</h1><a id="logo" href="/.">Rick2pc</a><p class="description">Wecome to my Blog !!!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta">2022-07-23</div><div class="post-content"><p>title: “基于C++的数据结构”</p>
<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><h2 id="1-Abstract-Data-Type-ADT"><a href="#1-Abstract-Data-Type-ADT" class="headerlink" title="1. Abstract Data Type (ADT)"></a>1. Abstract Data Type (ADT)</h2><h3 id="1-1-Data-type"><a href="#1-1-Data-type" class="headerlink" title="1.1. Data type"></a>1.1. Data type</h3><ul>
<li><p><strong>A set of objects + a set of operations</strong>    </p>
</li>
<li><p><strong>Example: integer</strong></p>
</li>
</ul>
<p>  ​                  <strong>— set of whole numbers</strong></p>
<p>  ​                  <strong>— operations: +,-,*,&#x2F;</strong></p>
<h3 id="1-2-Abstract-data-type"><a href="#1-2-Abstract-data-type" class="headerlink" title="1.2. Abstract data type"></a>1.2. Abstract data type</h3><ul>
<li><strong>High-level abstractions (managing complexity through abstraction)</strong></li>
<li><strong>Encapsulation（封装）</strong></li>
</ul>
<h3 id="1-3-Encapsulation-封装"><a href="#1-3-Encapsulation-封装" class="headerlink" title="1.3. Encapsulation(封装)"></a>1.3. Encapsulation(封装)</h3><ul>
<li><strong>Operation on the <em>ADT</em> can only be done by calling the  appropriate function.</strong></li>
<li><strong>No mention of <em>how</em> the set of operations is implemented.</strong></li>
</ul>
<p>​        (没有提到操作集是如何实现的)</p>
<ul>
<li><p><strong>The definition of the type and all operations on that type can be  localized to one section of the program</strong>. </p>
</li>
<li><p><strong>If we wish to change the implementation of an ADT</strong></p>
<p>​                   —<strong>We know where to look.</strong></p>
<p>​                   —<strong>By revising one small section we can be sure that there is no  subtlety elsewhere that will cause errors.</strong> </p>
</li>
<li><p><strong>We can treat the <em>ADT</em> as a primitive type(基本类型): we have no concern  with the underlying implementation.</strong> </p>
<ol>
<li><em><strong>ADT*—-&gt;C++:  *Class</strong></em></li>
<li><em><strong>Method*—-&gt;C++:*Member Function</strong></em></li>
</ol>
</li>
</ul>
<h3 id="1-4-ADT"><a href="#1-4-ADT" class="headerlink" title="1.4. ADT"></a>1.4. ADT</h3><ul>
<li><strong>Example</strong><ol>
<li><strong>The set <em>ADT</em></strong><ul>
<li><strong>A set of elements</strong>   </li>
<li><strong>Operations: union, intersection, size and complement.</strong></li>
</ul>
</li>
<li><strong>The queue <em>ADT</em></strong><ul>
<li><strong>A set of sequences of elements</strong></li>
<li><strong>Operations: create empty queue, insert, examine, delete,  and destroy queue.</strong></li>
</ul>
</li>
</ol>
</li>
<li><strong>Two <em>ADT’s</em> are different if they have the same underlying model  but different operations</strong><ul>
<li><strong>E.g. a different set <em>ADT</em> with only the union and find operations</strong> </li>
<li><strong>The appropriateness of an implementation depends very much  on the operations to be performed.</strong></li>
</ul>
</li>
</ul>
<h3 id="1-5-Pros-and-Con"><a href="#1-5-Pros-and-Con" class="headerlink" title="1.5. Pros and Con"></a>1.5. Pros and Con</h3><ul>
<li><strong>Implementation of the <em>ADT</em> is separate from its use.</strong> </li>
<li><strong>Modular: one module for one <em>ADT</em></strong></li>
</ul>
<p>​               <strong>— Easier to debug</strong></p>
<p>​               <strong>— Easier for several people to work simultaneously.</strong></p>
<ul>
<li><p><strong>Code for the <em>ADT</em> can be reused in different applications.</strong></p>
</li>
<li><p><strong>Information hiding</strong></p>
</li>
</ul>
<p>​              <strong>—A logical unit to do a specific job.</strong> </p>
<p>​              <strong>—Implementation details can be changed without affecting user programs.</strong></p>
<ul>
<li><strong>Allow rapid prototyping</strong></li>
</ul>
<p>​              <strong>— Prototype with simple <em>ADT</em> implementations, then tune them later when  necessary.</strong></p>
<ul>
<li><strong>Loss of efficiency</strong></li>
</ul>
<h2 id="2-Linked-List-ADT"><a href="#2-Linked-List-ADT" class="headerlink" title="2. Linked List ADT"></a>2. Linked List ADT</h2><h3 id="2-1-The-element-in-the-x3D-x3D-“List-ADT”-x3D-x3D"><a href="#2-1-The-element-in-the-x3D-x3D-“List-ADT”-x3D-x3D" class="headerlink" title="2.1. The element in the &#x3D;&#x3D;“List ADT”&#x3D;&#x3D;"></a>2.1. The element in the <em>&#x3D;&#x3D;“List ADT”&#x3D;&#x3D;</em></h3><ol>
<li><strong>The elements in the list: A<sub>1</sub>,A<sub>2</sub>,…A<sub>n</sub></strong></li>
<li><strong>N: the length of the list</strong></li>
<li><strong>A<sub>1</sub>: the first element.</strong></li>
<li><strong>A<sub>n</sub>: the nth element.</strong></li>
<li><strong>If N &#x3D;0, the the list is empty.</strong></li>
<li><strong>Linearly ordered.</strong></li>
</ol>
<p>$$<br>\begin{cases}<br>A_i,precedes,A_i+1\<br>A_i,follows,A_i-1<br>\end{cases}<br>$$</p>
<h3 id="2-2-Operations"><a href="#2-2-Operations" class="headerlink" title="2.2.  Operations"></a>2.2.  <strong>Operations</strong></h3><ol>
<li><p><strong>makeEmpty: Create an empty list.</strong>(Actually it is not in the implement.)</p>
</li>
<li><p><strong>insert: insert an object to a list.</strong></p>
<p>—Example:</p>
<p>​     insert(x,3)-&gt; 34,12,52,x,16,12</p>
<p>​     (insert x in the position “3”) </p>
</li>
<li><p><strong>remove: delete an element from the list.</strong></p>
<p>—Example:</p>
<p>remove(52)-&gt;34,12,x,16,12</p>
<p>(The element “52” is moved out the list.)</p>
</li>
<li><p><strong>find: locate the position of an object in a list.</strong></p>
<p>—Example:</p>
<p>list: 34,12,52,16,12;</p>
<p>find(52)-&gt;3;</p>
</li>
<li><p><strong>printList: print the list.</strong></p>
</li>
</ol>
<h3 id="2-3-There-are-two-standard-implementations-for-the-list-ADT"><a href="#2-3-There-are-two-standard-implementations-for-the-list-ADT" class="headerlink" title="2.3. There are two standard implementations for the list ADT:"></a>2.3. There are two standard implementations for the list <em>ADT</em>:</h3><p>$$<br>\begin{cases}<br>Array-based\<br>Linked,List<br>\end{cases}<br>$$</p>
<h4 id="2-3-1-Array-Implementation"><a href="#2-3-1-Array-Implementation" class="headerlink" title="2.3.1. Array Implementation"></a>2.3.1. Array Implementation</h4><p>​        <strong>Elements are stored in contiguous array  positions.</strong> </p>
<p><img src="https://img-blog.csdnimg.cn/98ecc249aab24bec83ac029f260aa7f0.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>Requires an estimate of the maximum size of the list. (waste space)</strong></p>
</li>
<li><p>$$<br>\begin{cases}<br>PrintList,and,find:,linear\<br>findKth:,constant\<br>insert, and ,delete:,slow<br>\end{cases}<br>$$</p>
<p><strong>Two extremely case:</strong></p>
<p>​    <strong>1. e.g. insert at position “0” (making a new element)</strong></p>
<ul>
<li><p>require first pushing the entire array down one spot to make room</p>
<p>(如果是在位置“0”插入一个值，那么后面的每一个值都要向后挪移一位，这样的算法比较繁琐。)</p>
</li>
</ul>
<p>   <strong>2. e.g. delete at position “0”</strong></p>
<ul>
<li><p>require shifting all the elements in the list up one</p>
<p>(遇上一种情况相似，但是每一位向上移动一位)</p>
</li>
</ul>
</li>
<li><p>On average, half of the lists needs to be moved for either operation</p>
</li>
</ol>
<h4 id="2-3-2-Pointer-Implementation-x3D-x3D-Linked-List-x3D-x3D"><a href="#2-3-2-Pointer-Implementation-x3D-x3D-Linked-List-x3D-x3D" class="headerlink" title="2.3.2. Pointer Implementation(&#x3D;&#x3D;Linked List&#x3D;&#x3D;)"></a>2.3.2. Pointer Implementation(&#x3D;&#x3D;<em>Linked List</em>&#x3D;&#x3D;)</h4><p><img src="https://img-blog.csdnimg.cn/dd80e87812cb461489d35f6444db317f.bmp#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>Ensure that the list is not stored contiguously(连续地)(与array list的区别).</strong></p>
<p>-<strong>use a linked list.</strong></p>
<p>-<strong>A series of structures that are not necessarily adjacent in memory.</strong></p>
</li>
<li><p><strong>Each node contains the element and a pointer to a structure containing its successor.</strong></p>
<p>-<strong>The &#x3D;&#x3D;last&#x3D;&#x3D; cell’s next link points to &#x3D;&#x3D;NULL&#x3D;&#x3D;.</strong></p>
</li>
<li><p><strong>Compared to the array implementation:</strong></p>
<ol>
<li><p><strong>The pointer implementation uses only as much as space as is needed for the elements currently o  the list.</strong></p>
</li>
<li><p><strong>But requires space for the pointers in each cell.</strong></p>
</li>
</ol>
</li>
</ol>
<h5 id="2-3-2-1-Linked-list"><a href="#2-3-2-1-Linked-list" class="headerlink" title="2.3.2.1 Linked list"></a>2.3.2.1 <em>Linked list</em></h5><p>​    <strong>1. A &#x3D;&#x3D;Linked List&#x3D;&#x3D; is a series of connected &#x3D;&#x3D;nodes&#x3D;&#x3D;.</strong></p>
<p>​    <strong>2. Each node contains at least:</strong><br>$$<br>\begin{cases}<br>A,piece,of,data.\<br>Pointer,to,the,next, node, int ,the , list.<br>\end{cases}<br>$$<br>   <strong>3. &#x3D;&#x3D;Head&#x3D;&#x3D;: Pointer to the first node.</strong></p>
<p>   <strong>4. The last node points to &#x3D;&#x3D;NULL&#x3D;&#x3D;.</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0b2d6a1ca9ca4e38bf2d5c499049d77d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-3-2-2-The-code-of-Linked-List"><a href="#2-3-2-2-The-code-of-Linked-List" class="headerlink" title="2.3.2.2 The code of Linked List"></a>2.3.2.2 The code of Linked List</h5><h6 id="1-LinkedList-h"><a href="#1-LinkedList-h" class="headerlink" title="1. LinkedList.h"></a>1. LinkedList.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To change this license header, choose License Headers in Project Properties.</span></span><br><span class="line"><span class="comment"> * To change this template file, choose Tools | Templates</span></span><br><span class="line"><span class="comment"> * and open the template in the editor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * File:   LinkedList.h</span></span><br><span class="line"><span class="comment">  * Author: ericzhao</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">data</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> newData)</span></span>;</span><br><span class="line">    <span class="function">Node* <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNext</span><span class="params">(Node* newNext)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>() : <span class="built_in">head</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LinkedList</span>() ;</span><br><span class="line">    <span class="comment">/*Append element to the end of the list*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///*Insert an element &quot;num&quot; at specific position &quot;pos&quot;.</span></span><br><span class="line">    <span class="comment">//If &quot;pos==1&quot;, insert &quot;num&quot; as the first element. </span></span><br><span class="line">    <span class="comment">//If &quot;pos&lt;1&quot; or &quot;pos&gt;listSize&quot;, return false; else return true;*/</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">///*The number of elements in the list*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">///*Search element &quot;num&quot; from list. If exits, return the position; else return 0;*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">///*Remove an element at position &quot;pos&quot;. If fail to remove, return false;*/</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Print out all elements in the linked list*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* LINKEDLIST_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-LinkedList-cpp"><a href="#2-LinkedList-cpp" class="headerlink" title="2. LinkedList.cpp"></a>2. LinkedList.cpp</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedList.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;LinkedList.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Node::getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Node::setData</span><span class="params">(<span class="type">int</span> newData)</span> </span>&#123;</span><br><span class="line">	data = newData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">Node::getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Node::setNext</span><span class="params">(Node* newNext)</span> </span>&#123;</span><br><span class="line">	next = newNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LinkedList::append</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(number);</span><br><span class="line">		<span class="comment">//head-&gt;setNext(newNode);//why the next step cannot be this step? </span></span><br><span class="line">		head = newNode;</span><br><span class="line">		newNode-&gt;<span class="built_in">setNext</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;currIndex&quot; &lt;&lt; &quot;-&gt;&quot; &lt;&lt; currIndex &lt;&lt; endl;</span></span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(number);</span><br><span class="line">		prevNode-&gt;<span class="built_in">setNext</span>(newNode);</span><br><span class="line">		newNode-&gt;<span class="built_in">setNext</span>(currNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LinkedList::insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> listSize = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		listSize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; listSize &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;listSize - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (currNode &amp;&amp; currPos != pos) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currPos++;</span><br><span class="line">		&#125;</span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(num);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">			newNode-&gt;<span class="built_in">setNext</span>(head);</span><br><span class="line">			head = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prevNode-&gt;<span class="built_in">setNext</span>(newNode);</span><br><span class="line">			newNode-&gt;<span class="built_in">setNext</span>(currNode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkedList::getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> listSize = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		listSize++;<span class="comment">//final result is larger than the real size</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> listSize--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Search element &quot;num&quot; from list. If exits, return the position; else return 0;*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkedList::search</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (currNode &amp;&amp; currNode-&gt;<span class="built_in">getData</span>() != num) &#123;<span class="comment">//check whether the num in the linkedlist or not</span></span><br><span class="line">		prevNode = currNode;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		currIndex++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currNode-&gt;<span class="built_in">getData</span>() == num) &#123; <span class="keyword">return</span> currIndex; &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Remove an element at position &quot;pos&quot;. If fail to remove, return false;*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LinkedList::remove</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="keyword">while</span> (currNode &amp;&amp; pos != currIndex) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (currNode) &#123;<span class="comment">//check whether currNode is &quot;null&quot; or not，if it is &quot;null&quot;，that is prove the postion is out of range.</span></span><br><span class="line">			<span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">				prevNode-&gt;<span class="built_in">setNext</span>(currNode-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">				<span class="keyword">delete</span> currNode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">				<span class="keyword">delete</span> currNode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Print out all elements in the linked list*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LinkedList::display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//int listSize = 1;</span></span><br><span class="line">	<span class="comment">//int currPos = 1;</span></span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		cout &lt;&lt; currNode-&gt;<span class="built_in">getData</span>() &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		<span class="comment">//listSize++;</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkedList::~<span class="built_in">LinkedList</span>() &#123;</span><br><span class="line">	<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line">	Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		prevNode = currNode;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		<span class="keyword">delete</span> prevNode;</span><br><span class="line">		prevNode = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-main-cpp"><a href="#3-main-cpp" class="headerlink" title="3. main.cpp"></a>3. main.cpp</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp to test the LinkedList</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LinkedList.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    LinkedList* list = <span class="keyword">new</span> <span class="built_in">LinkedList</span>();</span><br><span class="line">  </span><br><span class="line">    list-&gt;<span class="built_in">append</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    list-&gt;<span class="built_in">append</span>(<span class="number">2</span>);</span><br><span class="line">    list-&gt;<span class="built_in">append</span>(<span class="number">3</span>);</span><br><span class="line">    list-&gt;<span class="built_in">append</span>(<span class="number">4</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    <span class="comment">/* list-&gt;insert(1, 400);</span></span><br><span class="line"><span class="comment">    list-&gt;display();*/</span></span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">4</span>, <span class="number">100</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">3</span>, <span class="number">200</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">6</span>, <span class="number">600</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">8</span>, <span class="number">600</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">insert</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*list-&gt;remove(8);</span></span><br><span class="line"><span class="comment">    list-&gt;display();*/</span><span class="comment">//test</span></span><br><span class="line"></span><br><span class="line">    list-&gt;<span class="built_in">remove</span>(<span class="number">-1</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line">    list-&gt;<span class="built_in">display</span>();</span><br><span class="line">    list-&gt;<span class="built_in">remove</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos1 = list-&gt;<span class="built_in">search</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The position of value 2 is:&quot;</span> &lt;&lt; pos1 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> pos2 = list-&gt;<span class="built_in">search</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The position of value 4 is:&quot;</span> &lt;&lt; pos2 &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> pos3 = list-&gt;<span class="built_in">search</span>(<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The position of value 1000 is:&quot;</span> &lt;&lt; pos3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> list;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-3-The-analysis-of-the-code"><a href="#2-3-2-3-The-analysis-of-the-code" class="headerlink" title="2.3.2.3 The analysis of the code"></a>2.3.2.3 The analysis of the code</h5><h6 id="1-The-operation-of-append"><a href="#1-The-operation-of-append" class="headerlink" title="1. The operation of append():"></a>1. The operation of <em>append()</em>:</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LinkedList::append</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(number);</span><br><span class="line">		<span class="comment">//head-&gt;setNext(newNode);//why the next step cannot be this step? </span></span><br><span class="line">		head = newNode;</span><br><span class="line">		newNode-&gt;<span class="built_in">setNext</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;currIndex&quot; &lt;&lt; &quot;-&gt;&quot; &lt;&lt; currIndex &lt;&lt; endl;</span></span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(number);</span><br><span class="line">		prevNode-&gt;<span class="built_in">setNext</span>(newNode);</span><br><span class="line">		newNode-&gt;<span class="built_in">setNext</span>(currNode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <em>First of all, we should check whether the “&#x3D;&#x3D;head&#x3D;&#x3D;” points anywhere, if not, then the “<em>Liked List</em>“ is an empty list. Then we create a “<em>newNode</em>“ to store the new element, since the list is empty, we let the “&#x3D;&#x3D;head&#x3D;&#x3D;” equal to the new node and by the function “setNext()” set the head next is empty, which is helpful for the latter append.</em></p>
<p>   <em>Secondly, since the list is not empty , our function move to the “else” part. There are many ways to do the “else” part, here I choose the way that create two node:”prevNode”, “currNode”. In the “while” loop, the condition that run out of the loop is check whether the “currNode” is empty or not. In the “while” loop, after every looping, we will update the “currNode”, then the “currNode” will point to its next position, so for the out-loop condition, when the “currNode” is NULL, the “while” loop will stop. But if there only have “currNode” then the later function will not easily implement what we want to do(because the “currNode” points to NULL), so that we need “prevNode” to store the “last” node in the list. So after the “while” loop, our “currNode” comes to the NULL, but the “prevNode” comes to the last node, which is point to the NULL(“currNode”). And then we can do append operation to let the “prevNode” point to the new element, and the new element points to the “currNode”—-the NULL.</em></p>
<h6 id="2-The-operation-of-insert"><a href="#2-The-operation-of-insert" class="headerlink" title="2. The operation of insert():"></a>2. The operation of insert():</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LinkedList::insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> listSize = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		listSize++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; listSize &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;listSize - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (currNode &amp;&amp; currPos != pos) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currPos++;</span><br><span class="line">		&#125;</span><br><span class="line">		Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">		newNode-&gt;<span class="built_in">setData</span>(num);</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">			newNode-&gt;<span class="built_in">setNext</span>(head);</span><br><span class="line">			head = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			prevNode-&gt;<span class="built_in">setNext</span>(newNode);</span><br><span class="line">			newNode-&gt;<span class="built_in">setNext</span>(currNode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <em>First, the “listSize” stores the size of the list, the size of the list is “listSize” -1, and the “listSize” will be updated in the first while loop.</em></p>
<p>  <em>Then the “if” function is to check whether the “pos” delivery into the insert() function is in in the range of the listSize. If not return false.</em></p>
<p>  <em>After check the whether the pos is available, the code goto the else part. It is the same idea of append().</em></p>
<h6 id="3-The-operation-of-getSize"><a href="#3-The-operation-of-getSize" class="headerlink" title="3. The operation of  getSize():"></a>3. The operation of  getSize():</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkedList::getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> listSize = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> currPos = <span class="number">1</span>;</span><br><span class="line">	Node* currNode = head;</span><br><span class="line">	<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">		currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">		listSize++;<span class="comment">//final result is larger than the real size</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> listSize--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <em>This code is a very simple function to return the size of the Linked List, it has the same principle with the first part of the insert( ) function.</em></p>
<h6 id="4-The-operation-of-remove"><a href="#4-The-operation-of-remove" class="headerlink" title="4. The operation of remove() :"></a>4. The operation of remove() :</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LinkedList::remove</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> currIndex = <span class="number">1</span>;</span><br><span class="line">		Node* prevNode = <span class="literal">NULL</span>;</span><br><span class="line">		Node* currNode = head;</span><br><span class="line">		<span class="keyword">while</span> (currNode &amp;&amp; pos != currIndex) &#123;</span><br><span class="line">			prevNode = currNode;</span><br><span class="line">			currNode = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">			currIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (currNode) &#123;<span class="comment">//check whether currNode is &quot;null&quot; or not，if it is &quot;null&quot;，that is prove the postion is out of range.</span></span><br><span class="line">			<span class="keyword">if</span> (prevNode) &#123;</span><br><span class="line">				prevNode-&gt;<span class="built_in">setNext</span>(currNode-&gt;<span class="built_in">getNext</span>());</span><br><span class="line">				<span class="keyword">delete</span> currNode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				head = currNode-&gt;<span class="built_in">getNext</span>();</span><br><span class="line">				<span class="keyword">delete</span> currNode;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <em>The ability of this function is remove the element in the given position in the list.</em></p>
<p>  <em>First, the “if” equation is to check whether the pasted position is possible or not.</em></p>
<p>  Move to the “else” part, the conditions of break the while loop are: 1. Whether the currNode is NULL or not &#x3D;&#x3D;and&#x3D;&#x3D; whether the pasted position is out of the range of the Linked List or not. </p>
<p>  <em>After the while loop break, there is going to check what the condition make the it stop. So in the “if condition” we are going to check whether the currNode is NULL or not, if it is “null”，that proves the position is out of range, then it will return “false”. Oppositely, it will go to the “if”. For the “if” condition: if(prevNode), it is check the position is “1” or not, if it is “1”, then the while loop will not work,  and the prevNode is NULL. Remove operation is easy to understand, let the prevNode points to the next node of currNode, and delete the currNode.</em></p>
<h6 id="5-The-display-function"><a href="#5-The-display-function" class="headerlink" title="5. The display function"></a>5. The display function</h6><p><strong>The display function is easy to understand, so I will not analysis here.</strong></p>
<h2 id="3-Stacks-and-Queues"><a href="#3-Stacks-and-Queues" class="headerlink" title="3.  Stacks and Queues"></a>3.  Stacks and Queues</h2><h3 id="3-1-Stacks"><a href="#3-1-Stacks" class="headerlink" title="3.1 Stacks"></a>3.1 Stacks</h3><h4 id="3-1-1-Stacks-ADT"><a href="#3-1-1-Stacks-ADT" class="headerlink" title="3.1.1 Stacks ADT"></a>3.1.1 Stacks ADT</h4><ul>
<li><strong>A &#x3D;&#x3D;stack&#x3D;&#x3D; is a &#x3D;&#x3D;list&#x3D;&#x3D; in which insertion and deletion take place at the same end</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/648aaed9bd6f4d4e8203baf3135abfc9.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>The end of “2” is called &#x3D;&#x3D;”<em>top</em>“&#x3D;&#x3D;.</strong></p>
</li>
<li><p><strong>The other end is called &#x3D;&#x3D;”<em>bottom</em>“&#x3D;&#x3D;.</strong></p>
</li>
<li><p><strong>Stacks are know as &#x3D;&#x3D;”<em>LIFO</em>“&#x3D;&#x3D; (Last in, First out) lists.</strong></p>
<ul>
<li><strong>The last element inserted will be the first to be retrieved.</strong></li>
</ul>
</li>
</ul>
<h4 id="3-1-2-Push-and-Pop"><a href="#3-1-2-Push-and-Pop" class="headerlink" title="3.1.2 Push and Pop"></a>3.1.2 Push and Pop</h4><ul>
<li><strong>Primary operations: &#x3D;&#x3D;Push&#x3D;&#x3D; and &#x3D;&#x3D;Pop&#x3D;&#x3D;.</strong></li>
</ul>
<p>​         -<strong>Push:</strong></p>
<p>​            <strong>Add an element to the top of the stack.</strong></p>
<p>​         -<strong>Pop:</strong></p>
<p>​            <strong>Remove the element at the top of the stack.</strong></p>
<p><img src="https://img-blog.csdnimg.cn/93eabac1cc1b48b7af4df7887ec7a990.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-1-3-Implementation-of-Stacks"><a href="#3-1-3-Implementation-of-Stacks" class="headerlink" title="3.1.3 Implementation of Stacks"></a>3.1.3 Implementation of Stacks</h4><p>$$<br>\begin{cases}<br>Array,(static:,the, size, of, stack, is ,given ,initially.)\<br>LinkedList,(dynamic: never, become, full.)<br>\end{cases}<br>$$</p>
<h5 id="1-Based-on-array"><a href="#1-Based-on-array" class="headerlink" title="1. Based on array"></a>1. Based on array</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To change this license header, choose License Headers in Project Properties.</span></span><br><span class="line"><span class="comment"> * To change this template file, choose Tools | Templates</span></span><br><span class="line"><span class="comment"> * and open the template in the editor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRAYSTACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAYSTACK_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">double</span>* values;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayStack</span>(<span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">ArrayStack</span>() &#123;<span class="keyword">delete</span> values;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> top==<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> top == maxSize;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span> <span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisplayStack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ARRAYSTACK_H */</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To change this license header, choose License Headers in Project Properties.</span></span><br><span class="line"><span class="comment"> * To change this template file, choose Tools | Templates</span></span><br><span class="line"><span class="comment"> * and open the template in the editor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ArrayStack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ArrayStack::<span class="built_in">ArrayStack</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">    values = <span class="keyword">new</span> <span class="type">double</span>[size];</span><br><span class="line">    maxSize = size<span class="number">-1</span>;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArrayStack::Push</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Put your code here</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsFull</span>()) <span class="comment">// if stack is full, print error</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error: the stack is full.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</span></span><br><span class="line">		values[++top] = x;<span class="comment">//First update the top, in array satck, when the top pushs in the array, it will add into the behind of the last member. so the lst member is the top</span></span><br><span class="line">		<span class="comment">/*cout &lt;&lt; &quot;here&quot; &lt;&lt; endl;*/</span></span><br><span class="line">		cout &lt;&lt; top &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ArrayStack::Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Put your code here</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123; <span class="comment">//if stack is empty, print error</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error: the stack is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> values[top--];<span class="comment">//From the test, the fuction will return the value &quot;values[top]&quot; firstly, and then top will decrease 1 position, then the original top will be pop out the stack!! </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ArrayStack::Top</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//Put your code here</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error: the stack is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> values[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArrayStack::DisplayStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;top -- &gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (i == top) cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot;\t|&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;\t|&quot;</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot;\t|&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t|-------|&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">ArrayStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	stack.<span class="built_in">Push</span>(<span class="number">5.0</span>);</span><br><span class="line">	stack.<span class="built_in">Push</span>(<span class="number">6.5</span>);</span><br><span class="line">	stack.<span class="built_in">Push</span>(<span class="number">-3.0</span>);</span><br><span class="line">	stack.<span class="built_in">Push</span>(<span class="number">-8.0</span>);</span><br><span class="line">	<span class="comment">//stack.Push(-9.0);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//stack.Push(-10.0);</span></span><br><span class="line">	stack.<span class="built_in">DisplayStack</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Top: &quot;</span> &lt;&lt; stack.<span class="built_in">Top</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*cout &lt;&lt;&quot;a&quot;&lt;&lt;*/</span> stack.<span class="built_in">Pop</span>() <span class="comment">/*&lt;&lt; endl*/</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Top: &quot;</span> &lt;&lt; stack.<span class="built_in">Top</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!stack.<span class="built_in">IsEmpty</span>()) stack.<span class="built_in">Pop</span>();</span><br><span class="line">	stack.<span class="built_in">DisplayStack</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-Based-on-Linked-list"><a href="#2-Based-on-Linked-list" class="headerlink" title="2. Based on Linked list"></a>2. Based on Linked list</h5><ul>
<li>Now let’s implement a stack based on a linked list.</li>
<li>To make the best out of the code of List, we  implement Stack by inheriting List.</li>
<li>To let Stack access private member head, we make  Stack as a friend of List.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">List</span>(<span class="type">void</span>) &#123; head = <span class="literal">NULL</span>; &#125; <span class="comment">// constructor</span></span><br><span class="line">~<span class="built_in">List</span>(<span class="type">void</span>); <span class="comment">// destructor</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> head == <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="function">Node* <span class="title">InsertNode</span><span class="params">(<span class="type">int</span> index, <span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindNode</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteNode</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayList</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* head;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Stack</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> : <span class="keyword">public</span> List &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>() &#123;&#125; <span class="comment">// constructor</span></span><br><span class="line">~<span class="built_in">Stack</span>() &#123;&#125; <span class="comment">// destructor</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Top</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: the stack is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> <span class="type">double</span> x)</span> </span>&#123; <span class="built_in">InsertNode</span>(<span class="number">0</span>, x); &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: the stack is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">double</span> val = head-&gt;data;</span><br><span class="line"><span class="built_in">DeleteNode</span>(val);</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayStack</span><span class="params">()</span> </span>&#123; <span class="built_in">DisplayList</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/58ec04b85ac44383a88813ad2574299a.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c9e505482e854e2398b2fe6690e47a79.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-2-Queue"><a href="#3-2-Queue" class="headerlink" title="3.2 Queue"></a>3.2 Queue</h3><h4 id="3-2-1-Queue-ADT"><a href="#3-2-1-Queue-ADT" class="headerlink" title="3.2.1 Queue ADT"></a>3.2.1 Queue ADT</h4><ul>
<li><p>Like a stack, a queue is also a list. However, with a  queue, insertion is done at one end, while deletion is  performed at the other end .</p>
</li>
<li><p>Accessing the elements of queues follows a &#x3D;&#x3D;First In,  First Out (FIFO)&#x3D;&#x3D; order. </p>
</li>
<li><p>Like customers standing in a check-out line in a store, the  first customer in is the first customer served.</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/61c1e96fc2f94da793c09e1d78759dc1.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-2-2-Enqueue-and-Dequeue"><a href="#3-2-2-Enqueue-and-Dequeue" class="headerlink" title="3.2.2 Enqueue and Dequeue"></a>3.2.2 Enqueue and Dequeue</h4><ul>
<li><p>Primary queue operations: Enqueue and Dequeue </p>
</li>
<li><p>Like check-out lines in a store, a queue has a &#x3D;&#x3D;front and a rear&#x3D;&#x3D;. </p>
</li>
<li><p>Enqueue – insert an element at the rear of the  queue. </p>
</li>
<li><p>Dequeue – remove an element from the front of  the queue<br><img src="https://img-blog.csdnimg.cn/8856cf87a7794a07a4c50b645fdcb134.bmp#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="3-2-3-Implement"><a href="#3-2-3-Implement" class="headerlink" title="3.2.3 Implement"></a>3.2.3 Implement</h4><p>$$<br>\begin{cases}<br>Array,(static:,the, size, of, stack, is ,given ,initially.)\<br>LinkedList,(dynamic: never, become, full.)<br>\end{cases}<br>$$</p>
<h5 id="1-Based-on-array-1"><a href="#1-Based-on-array-1" class="headerlink" title="1. Based on array"></a>1. Based on array</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To change this license header, choose License Headers in Project Properties.</span></span><br><span class="line"><span class="comment"> * To change this template file, choose Tools | Templates</span></span><br><span class="line"><span class="comment"> * and open the template in the editor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CIRCULARARRAYQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCULARARRAYQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularArrayQueue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span>* values;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularArrayQueue</span>(<span class="type">int</span> size);</span><br><span class="line">    ~<span class="built_in">CircularArrayQueue</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Enqueue</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Dequeue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisplayQueue</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CIRCULARARRAYQUEUE_H */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Use circular array to implement a queue ADT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CircularArrayQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">CircularArrayQueue::<span class="built_in">CircularArrayQueue</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">    values = <span class="keyword">new</span> <span class="type">double</span>[size];</span><br><span class="line">    maxSize = size;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">-1</span>;</span><br><span class="line">    counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CircularArrayQueue::IsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Put your code here</span></span><br><span class="line">    <span class="keyword">if</span> (counter) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CircularArrayQueue::IsFull</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Put your code here</span></span><br><span class="line">    <span class="keyword">if</span> (counter &lt; maxSize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CircularArrayQueue::Enqueue</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//Put your code here</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: the queue is full.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// calculate the new rear position (circular)</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="comment">// insert new item</span></span><br><span class="line">        values[rear] = x;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;here&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; rear &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// update counter</span></span><br><span class="line">        counter++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">CircularArrayQueue::Dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Put your code here</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error: the queue is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">          </span><br><span class="line">            <span class="comment">// move front</span></span><br><span class="line">            <span class="type">int</span> old = front;</span><br><span class="line">            front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">            <span class="comment">// update counter</span></span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">return</span> values[old];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CircularArrayQueue::DisplayQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;front --&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;counter; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; <span class="string">&quot;\t\t&quot;</span>; </span><br><span class="line">        cout &lt;&lt; values[(front + i) % maxSize];</span><br><span class="line">        <span class="keyword">if</span> (i != counter - <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\t&lt;-- rear&quot;</span> &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    CircularArrayQueue* queue = <span class="keyword">new</span> <span class="built_in">CircularArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Enqueue 5 items.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">		queue-&gt;<span class="built_in">Enqueue</span>(x);	</span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now attempting to enqueue again...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	queue-&gt;<span class="built_in">Enqueue</span>(<span class="number">5</span>);</span><br><span class="line">	queue-&gt;<span class="built_in">DisplayQueue</span>();	</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> val = queue-&gt;<span class="built_in">Dequeue</span>();</span><br><span class="line">    <span class="comment">//queue-&gt;DisplayQueue();jj</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Retrieved element = &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;2&quot; &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">	queue-&gt;<span class="built_in">DisplayQueue</span>();</span><br><span class="line">    <span class="type">double</span> val1 = queue-&gt;<span class="built_in">Dequeue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Retrieved element = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">	queue-&gt;<span class="built_in">Enqueue</span>(<span class="number">7</span>);</span><br><span class="line">	queue-&gt;<span class="built_in">DisplayQueue</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-Based-on-Linked-list-1"><a href="#2-Based-on-Linked-list-1" class="headerlink" title="2. Based on Linked list"></a>2. Based on Linked list</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Queue</span>() &#123; <span class="comment">// constructor</span></span><br><span class="line">front = rear = <span class="literal">NULL</span>;</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Queue</span>() &#123; <span class="comment">// destructor</span></span><br><span class="line"><span class="type">double</span> value;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>()) <span class="built_in">Dequeue</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (counter) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dequeue</span><span class="params">(<span class="type">double</span> &amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisplayQueue</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* front; <span class="comment">// pointer to front node</span></span><br><span class="line">Node* rear; <span class="comment">// pointer to last node</span></span><br><span class="line"><span class="type">int</span> counter; <span class="comment">// number of elements</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue::Enqueue</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node;</span><br><span class="line">newNode-&gt;data = x;</span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">front = newNode;</span><br><span class="line">rear = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">rear-&gt;next = newNode;</span><br><span class="line">rear = newNode;</span><br><span class="line">&#125;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1a411b11aaa54a1080c7e9374c929c5d.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Queue::Dequeue</span><span class="params">(<span class="type">double</span> &amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: the queue is empty.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">x = front-&gt;data;</span><br><span class="line">Node* nextNode = front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> front;</span><br><span class="line">front = nextNode;</span><br><span class="line">counter--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/0acd1d4662d24695a7b9c30e4a678bcb.bmp#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue::DisplayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front --&gt;&quot;</span>;</span><br><span class="line">Node* currNode = front;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t\t&quot;</span>; </span><br><span class="line">cout &lt;&lt; currNode-&gt;data;</span><br><span class="line"><span class="keyword">if</span> (i != counter - <span class="number">1</span>)</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t&lt;-- rear&quot;</span> &lt;&lt; endl;</span><br><span class="line">currNode = currNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-Analysis-of-Algorithms"><a href="#4-Analysis-of-Algorithms" class="headerlink" title="4. Analysis of Algorithms"></a>4. Analysis of Algorithms</h2><h3 id="4-1-Introduction"><a href="#4-1-Introduction" class="headerlink" title="4.1. Introduction"></a>4.1. Introduction</h3><ul>
<li><p><strong>What is Algorithm?</strong> </p>
<ul>
<li><p><strong>A clearly specified &#x3D;&#x3D;set of simple instructions&#x3D;&#x3D; to be followed to solved a problem</strong></p>
<ul>
<li><strong>Takes a set of vales, as input.</strong></li>
<li><strong>produces a value, or set of values, as output.</strong></li>
</ul>
</li>
<li><p><strong>May be specified</strong></p>
<ul>
<li><p><strong>In English.</strong></p>
</li>
<li><p><strong>As a computer program.</strong></p>
</li>
<li><p><strong>As a pseudo-code(伪代码).</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Data structures</strong></p>
<ul>
<li><strong>Methods of organizing data.</strong></li>
</ul>
</li>
<li><p><strong>Program &#x3D; algorithms + data structures</strong></p>
</li>
</ul>
<h3 id="4-2-Algorithm-Analysis"><a href="#4-2-Algorithm-Analysis" class="headerlink" title="4.2. Algorithm Analysis"></a>4.2. Algorithm Analysis</h3><ul>
<li><p><strong>We only analyze correct algorithm.</strong></p>
</li>
<li><p><strong>An algorithm is correct.</strong></p>
</li>
<li><p><strong>If, for every input instance, it halts with the correct output.</strong></p>
</li>
<li><p><strong>Incorrect algorithms</strong></p>
</li>
<li><p><strong>Might not halt at all on some input instances.</strong></p>
</li>
<li><p><strong>Might halt with other than the desired answer.</strong></p>
</li>
<li><p><strong>Analyzing an algorithm</strong></p>
</li>
<li><p><strong>&#x3D;&#x3D;Predicting&#x3D;&#x3D; the resources that the algorithm requires.</strong> </p>
</li>
<li><p><strong>Resources include</strong><br>- Memory<br>- Communication bandwidth<br>- Computational time(usually most important)</p>
</li>
<li><p><strong>Factors affecting the running time</strong>    </p>
</li>
<li><p>computer</p>
</li>
<li><p>compiler(编译器)</p>
</li>
<li><p>algorithm used</p>
</li>
<li><p>input to the algorithm</p>
<ul>
<li><p>The content of the input affects the running time. </p>
</li>
<li><p>Typically, the &#x3D;&#x3D;input size&#x3D;&#x3D; (number of items in the input) is the  main consideration. </p>
<p>  -E.g. sorting problem $\Rightarrow$  the number of items to be sorted.</p>
<p> -E.g. multiply two matrices together  $\Rightarrow$  the total number of  elements in the two matrices.</p>
</li>
</ul>
</li>
<li><p><strong>Machine model assumed</strong></p>
<ul>
<li>Instructions are executed one after another, with no concurrent  operations$\Rightarrow$ Not parallel computers.</li>
</ul>
</li>
</ul>
<h3 id="4-3-Time-Complexity"><a href="#4-3-Time-Complexity" class="headerlink" title="4.3. Time Complexity"></a>4.3. Time Complexity</h3><ul>
<li><p><strong>Worst case running time</strong></p>
<ul>
<li><p><strong>The longest running time for any &#x3D;&#x3D;input of size n&#x3D;&#x3D;.（问题的规模）</strong></p>
</li>
<li><p><strong>An upper bound on the running time for any input $\Rightarrow$ guarantee that the algorithm will never take longer.</strong>(You can think like the Big-Oh notation)</p>
</li>
<li><p><strong>Example: Sort a set of numbers in increasing order; and the data  is in decreasing order.</strong></p>
</li>
</ul>
<p>  &#x3D;&#x3D;The worst case can occur fairly often.&#x3D;&#x3D;</p>
</li>
</ul>
<ul>
<li><strong>Best case of an running time</strong><ul>
<li>Example: Sort a set of numbers in increasing order; and the data is already in increasing order.</li>
</ul>
</li>
<li><strong>Average case running time</strong></li>
<li>Difficult to define.</li>
</ul>
<h4 id="4-3-1-Big-Oh-Notation"><a href="#4-3-1-Big-Oh-Notation" class="headerlink" title="4.3.1 Big-Oh Notation"></a>4.3.1 Big-Oh Notation</h4><p><img src="https://img-blog.csdnimg.cn/9b215a29600e4ae189f4cf112f95373e.webp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>Definition</strong></p>
<ul>
<li><p><strong>$f(N)&#x3D;O(g(N))$ if there are positive constant <em>c</em> and $n_0$ such that $f(N)\leq cf(N)$ when $N\geq n_0$.</strong></p>
<p>(Never mind the <em>N</em> and the <em>n</em> in the formula. They all represent the size of the problem.)</p>
<p>($f(N)$的增长率小于或等于$g(N)$的增长率。for large <em>N</em>)</p>
<p>($f(N)&#x3D;O(g(N))$,表示随问题规模<em>N</em>的增大，算法执行时间的增长率和$g(N)$的增长率相同）</p>
<p>(实际上我看相关的教材上一般会习惯把这里面的$f(n)写作T(n)$可能是更好地表达时间复杂度的意思。）</p>
</li>
<li><p><strong>The growth rate of $f(N)$ is less than or equal to the growth rate of $g(N)$.</strong></p>
</li>
<li><p>&#x3D;&#x3D;<strong>$g(N), is ,an, upper, bound ,on, f(N).$</strong>&#x3D;&#x3D;</p>
</li>
<li><p>Example:</p>
<ul>
<li><p>Let $f(N)&#x3D;2N^2.$Then the probable answer is:</p>
<ul>
<li><p>$f(N)&#x3D;O(N^2)$</p>
</li>
<li><p>$f(N)&#x3D;O(N^3)$</p>
</li>
<li><p>$f(N)&#x3D;O(N^2)$</p>
<p>($f(N),&#x3D;,2N^2,for,c\geq2$</p>
<p>$\therefore,f(N),&#x3D;,O(N^2)$)</p>
</li>
</ul>
<p><strong>There are also many other answer, but the third answer in here is the best answer.</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Some  rules</strong></p>
<ul>
<li><p><strong>When considering the growth rate of a function using Big-Oh, ignore the lower order terms and the coefficients of the highest-order term.</strong></p>
<ul>
<li>Like:$f(N)&#x3D;3N^2+2N+1$ then $f(N)&#x3D;O(N^2)$.</li>
</ul>
</li>
<li><p><strong>No need to specify the base of logarithm.</strong></p>
<p>(不需要指定对数的底数。)</p>
<ul>
<li><p><strong>Changing the base from one constant to another changes the  value of the logarithm by only a constant factor.</strong> </p>
<p><strong>Like: $log_aN&#x3D;log_bN&#x2F;log_ba&#x3D;O(log_bN)&#x3D;O(logN)$.</strong></p>
</li>
</ul>
</li>
<li><p><strong>If $T_1(N)&#x3D;O(f(N))$ and $T_2(N)&#x3D;O(g(N))$, then：</strong></p>
<ul>
<li><ol>
<li>$T_1(N)+T_2(N)&#x3D;max(O(f(N)),O(g(N)))$</li>
</ol>
</li>
<li><ol start="2">
<li>$T_1(N)*T_2(N)&#x3D;O(f(N)*g(N))$</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-Big-Omega-Notation"><a href="#4-3-2-Big-Omega-Notation" class="headerlink" title="4.3.2 Big-Omega Notation"></a>4.3.2 Big-Omega Notation</h4><p><img src="https://img-blog.csdnimg.cn/632f67028b464ae5891b9b12ddea0e2c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>Definition</strong></p>
<ul>
<li><strong>$f(N)&#x3D;\Omega(g(N))$ if there are positive constant <em>c</em> and$n_0$ such that $f(N)\geq cg(N)$ when $N\geq n_0$.</strong></li>
<li><strong>$f(N)$ grows no slower than $g(N)$ for “large” <em>N</em></strong></li>
<li><strong>The growth rate of $f(N)$ is greater than or equal to the growth rate of $g(N)$.</strong></li>
</ul>
</li>
</ul>
<h4 id="4-3-3-Big-Theta-Notation"><a href="#4-3-3-Big-Theta-Notation" class="headerlink" title="4.3.3 Big-Theta Notation"></a>4.3.3 Big-Theta Notation</h4><p><img src="https://img-blog.csdnimg.cn/35337d2253b44bf79f0b6d2905862b93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>Definition</strong><ul>
<li><strong>$f(N)&#x3D;\Theta(g(N))$ if  and only if $T(N)&#x3D;O(g(N))$ and $T(N)&#x3D;\Omega(g(N))$.</strong></li>
<li><strong>The growth rate of $f(N)$ equals the growth rate of $g(N)$.</strong></li>
<li><strong>Big-Theta means the bound is the tightest  possible.</strong><ul>
<li>Example: $f(N)&#x3D;N^2, g(N)&#x3D;2N^2,,f(N)&#x3D;O(g(N)),and,f(N)&#x3D;\Omega(g(N)),thus,f(N)&#x3D;\Theta(g(N)).$</li>
</ul>
</li>
</ul>
</li>
<li><strong>Rules</strong>:<ul>
<li><ol>
<li><strong>If $T(N)$ is a polynomial of degree k, then  $T(N) &#x3D; \Theta(N^k) .$</strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>For logarithmic functions, $T(log_m N) &#x3D; \Theta(log N).$</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-4-General-Rules"><a href="#4-3-4-General-Rules" class="headerlink" title="4.3.4 General Rules"></a>4.3.4 General Rules</h4><p><img src="https://img-blog.csdnimg.cn/9fd29ac4519744a4b2886bbebbf2c46f.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>&#x3D;&#x3D;Using L’Hopital’s Rule&#x3D;&#x3D;</strong></p>
<ul>
<li><strong>&#x3D;&#x3D;Determine the relative growth rates (using  L’Hopital’s rule if  necessary)&#x3D;&#x3D;</strong></li>
<li>Compute $$\lim\limits_{x\rightarrow\infty}\frac{f(N)}{g(N)}$$</li>
<li>if 0: $f(N)&#x3D;O(g(N))$ and $f(N)$ is not $\Theta(g(N))$($f(N)&#x3D;o(g(N))$).</li>
<li>if constant , but not equal to 0: $f(N)&#x3D;\Theta(g(N))$.</li>
<li>if$\infin$: $f(N)&#x3D;\Omega(g(N)),and,f(N),is,not,\Theta(g(N))$($g(N)&#x3D;o(f(n))$).</li>
<li>limit oscillates: no relation.</li>
</ul>
</li>
<li><p><strong>Stirling’s approximation</strong></p>
<p>-<img src="https://img-blog.csdnimg.cn/66baeb86a129467fbcc6294a1fd92b75.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>Example:</p>
<p> $f(n)&#x3D;log_{2}(n!) ,and ,g(n)&#x3D;nlog_{2}n$;</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/682294986ee049c381af55b4bb327df4.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>Running time calculation</strong></p>
<ul>
<li><p><strong>Rule 1- For loop:</strong></p>
<ul>
<li><strong>The running time of a for loop is at most the running time of the statements inside the for loop (including tests) times the number of iterations.</strong></li>
</ul>
</li>
<li><p><strong>Rule 2—Nested loops</strong>(嵌套循环)</p>
</li>
<li><p><strong>Analyze these inside out. The total running time of a statement inside a group of nested loops is the running time of the statement multiplied by the product of the sizes of all the loops.</strong></p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">	<span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">		++k;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>Rule 3—Consecutive Statements</strong> </p>
</li>
<li><p>$T_1(N)+T_2(N)&#x3D;max(O(f(N)),O(g(N)))$ </p>
</li>
<li><p>$T_1(N)*T_2(N)&#x3D;O(f(N)*g(N))$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">	a[ i ] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">	<span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">		a[ i ] += a[ j ] + i + j;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Rule 4—If&#x2F;Else</strong></p>
</li>
<li><p>The running time of an if&#x2F;else statement is never more than the running time of the test plus the larger of the running times of $S_1$ and $S_2$.</p>
</li>
</ul>
</li>
</ul>
<p>​         <em>Other rules are obvious, but a basic strategy of analyzing from the inside (or deepest part) out works. If there are function calls, these must be analyzed first. If there are recursive functions, there are several options. If the recursion is really just a thinly veiled for loop, the analysis is usually trivial. For instance, the following function is really just a simple loop and is O(N):</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">factorial</span><span class="params">( <span class="type">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n &lt;= <span class="number">1</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n * <span class="built_in">factorial</span>( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         <em>This example is really a poor use of recursion. When recursion is properly used, it is difficult to convert the recursion into a simple loop structure. In this case, the analysis will involve a recurrence relation that needs to be solved. To see what might happen, consider the following program, which turns out to be a terrible use of recursion:</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="type">long</span> <span class="title">fib</span><span class="params">( <span class="type">int</span> n )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"><span class="number">1</span> 		<span class="keyword">if</span>( n &lt;= <span class="number">1</span> )</span><br><span class="line"><span class="number">2</span> 			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line"><span class="number">3</span> 			<span class="keyword">return</span> <span class="built_in">fib</span>( n - <span class="number">1</span> ) + <span class="built_in">fib</span>( n - <span class="number">2</span> );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​         At first glance, this seems like a very clever use of recursion. However, if the program is coded up and run for values of N around 40, it becomes apparent that this program   is terribly inefficient. The analysis is fairly simple. Let T(N) be the running time for the function call fib(n). If $N &#x3D; 0$ or $N &#x3D; 1$, then the running time is some constant value, which is the time to do the test at line 1 and return. We can say that $T(0) &#x3D; T(1) &#x3D; 1$ because constants do not matter. The running time for other values of <em>N</em> is then measured relative to the running time of the base case. For $N &gt; 2$, the time to execute the function is the constant work at line 1 plus the work at line 3. Line 3 consists of an addition and two function calls. Since the function calls are not simple operations, they must be analyzed by themselves. The first function call is $fib(n-1)$ and hence, by the definition of $T$, requires $T(N − 1)$ units of time. A similar argument shows that the second function call requires $T(N − 2)$ units of time. The total time required is then $T(N − 1) + T(N − 2) + 2$, where the 2 accounts for the work at line 1 plus the addition at line 3. Thus, for $N ≥ 2$, we have the following formula for the running time of $fib(n)$: </p>
<p>​       													      $T(N) &#x3D; T(N − 1) + T(N − 2) + 2$		</p>
<p>​          Since $fib(n) &#x3D; fib(n-1) + fib(n-2)$, it is easy to show by induction that T(N) ≥ fib(n). In Section 1.2.5, we showed that fib(N) &lt; (5&#x2F;3)N. A similar calculation shows that (for N &gt; 4) $fib(N) ≥ (3&#x2F;2)N$, and so the running time of this program grows exponentially. This is about as bad as possible. By keeping a simple array and using a for loop, the running time can be reduced substantially. </p>
<h3 id="4-4-Cases-study-The-Maximum-Subsequence-Sum-Problem"><a href="#4-4-Cases-study-The-Maximum-Subsequence-Sum-Problem" class="headerlink" title="4.4 Cases study:  The Maximum Subsequence Sum Problem."></a>4.4 Cases study:  The Maximum Subsequence Sum Problem.</h3><h4 id="4-4-1-The-maximum-subsequence-sum-problem"><a href="#4-4-1-The-maximum-subsequence-sum-problem" class="headerlink" title="4.4.1 The maximum subsequence sum problem"></a>4.4.1 The maximum subsequence sum problem</h4><ul>
<li>Given(possible negative) integers $A_1,A_2,…,A_n$ find the maximum value of $\sum_{k&#x3D;i}^{j}A_k$.<ul>
<li>For convenience, the maximum subsequence sum is 0  if all the integers are negative.</li>
</ul>
</li>
</ul>
<h4 id="4-4-2-Algorithms-of-the-cases-and-analysis"><a href="#4-4-2-Algorithms-of-the-cases-and-analysis" class="headerlink" title="4.4.2  Algorithms of the cases and analysis"></a>4.4.2  Algorithms of the cases and analysis</h4><h5 id="Case-1-Brute-Force-暴力穷举"><a href="#Case-1-Brute-Force-暴力穷举" class="headerlink" title="Case 1: Brute Force(暴力穷举)"></a>Case 1: Brute Force(暴力穷举)</h5><h6 id="1-1-Code"><a href="#1-1-Code" class="headerlink" title="1.1 Code"></a>1.1 Code</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubSeqSum_BruteForce</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size, <span class="type">int</span>&amp; max_start, <span class="type">int</span>&amp; max_end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*implement the function body below.</span></span><br><span class="line"><span class="comment">    max_start and max_end are used to return theo start and end index of the max subsequence found by the algorithm*/</span></span><br><span class="line">    <span class="type">int</span> sum_max = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                sum = sum + arr[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; sum_max) &#123;</span><br><span class="line">                sum_max = sum;</span><br><span class="line">                max_start = i;</span><br><span class="line">                max_end = j;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-2-Algorithm-analysis"><a href="#1-2-Algorithm-analysis" class="headerlink" title="1.2  Algorithm analysis"></a>1.2  Algorithm analysis</h6><ol>
<li><p>The Time Complexity</p>
<p>The most important part of the code if the third for loop if we can calculate the time of it spend, than we can get the time complexity of the whole function.</p>
<p>So there may be a roughly sum of the time that the code go through:&#x3D;&#x3D;$\sum_{i&#x3D;0}^{N-1}\sum_{j&#x3D;i}^{N-1}\sum_{k&#x3D;i}^{j}1$&#x3D;&#x3D;, where N represent the size of the problem.</p>
<p>​	-First :   $\sum_{k&#x3D;i}^{j}1&#x3D;j-i+1;$</p>
<p>​    -Second: $\sum_{j&#x3D;i}^{N-1}(j-i+1)&#x3D;(N-i+1)(N-i)&#x2F;2;$</p>
<p>​	-Third: $\sum_{i&#x3D;0}^{N-1}(N-i+1)(N-i)&#x2F;2&#x3D;(N^3+3N^2+2N)&#x2F;6$</p>
<p>  Then the final result is the third result, then the time complexity: &#x3D;&#x3D;$T(N)&#x3D;O(N^3)$&#x3D;&#x3D;;</p>
</li>
<li><p>Code Explain: </p>
<p>这里我们用中文解释一下代码的原理：</p>
<p>首先声明：对于暴力穷举算法， 它的时间复杂度为$O(N^3)$根据我们的认识，这样大的指数级别的时间复杂度是极不利于我们面对大量级的数据时调用该函数解决问题。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b93c702d4a03410897fa62f991364c78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUmljazJwYw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="Case-2-Divide-and-Conquer-分而治之"><a href="#Case-2-Divide-and-Conquer-分而治之" class="headerlink" title="Case 2: Divide and Conquer (分而治之)"></a>Case 2: Divide and Conquer (分而治之)</h5><p><a name="Divide and Conquer"></a></p>
<h6 id="2-1-What-is-“Divide-and-Conquer”"><a href="#2-1-What-is-“Divide-and-Conquer”" class="headerlink" title="2.1 What is “Divide and Conquer” ?"></a>2.1 What is “Divide and Conquer” ?</h6><ol>
<li>Split the problem into two roughly equal subproblems, which are  then solved &#x3D;&#x3D;recursively&#x3D;&#x3D;.</li>
<li>Patch together the two solutions of the subproblems to arrive at a  solution for the whole problem.</li>
<li>The maximum subsequence sum can be:<ul>
<li>Entirely in the left half of the input. </li>
<li>Entirely in the right half of the input. </li>
<li>It crosses the middle and is in both halves.</li>
</ul>
</li>
</ol>
<h6 id="2-2-A-case-of-the-“Divide-and-Conquer”-to-help-you-know-about-it"><a href="#2-2-A-case-of-the-“Divide-and-Conquer”-to-help-you-know-about-it" class="headerlink" title="2.2 A case of the “Divide and Conquer” to help you know about it."></a>2.2 A case of the “Divide and Conquer” to help you know about it.</h6><p>​                 <a name="图解分而治之算法"></a></p>
<p><img src="https://img-blog.csdnimg.cn/13b321eb3dd1492e8ff173a291d3de1d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h6 id="2-3-Code"><a href="#2-3-Code" class="headerlink" title="2.3 Code"></a>2.3 Code</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max_Divden</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span>&amp; start1, <span class="type">int</span>&amp; end1)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left_start; <span class="type">int</span> right_start; <span class="type">int</span> lr_start; <span class="type">int</span> left_end, right_end, lr_end;</span><br><span class="line">    <span class="keyword">if</span> (s == e) &#123; start1 = s; end1 = e; <span class="keyword">return</span> arr[s]; &#125;</span><br><span class="line">    <span class="type">int</span> midpoint = (s + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> Max_left_sum = <span class="built_in">Max_Divden</span>(arr, s, midpoint, left_start, left_end);</span><br><span class="line">    <span class="type">int</span> Max_right_sum = <span class="built_in">Max_Divden</span>(arr, midpoint + <span class="number">1</span>, e, right_start, right_end);</span><br><span class="line">    <span class="type">int</span> left_sum = INT_MIN; <span class="type">int</span> right_sum = INT_MIN; <span class="type">int</span> lr_sum;</span><br><span class="line">    <span class="type">int</span> left_wait = <span class="number">0</span>; <span class="type">int</span> right_wait = <span class="number">0</span>;<span class="comment">//wait to update</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = midpoint; i &gt;= s; i--) &#123;</span><br><span class="line">        left_wait += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (left_wait &gt; left_sum) &#123; left_sum = left_wait; lr_start = i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = midpoint + <span class="number">1</span>; j &lt;= e; j++) &#123;</span><br><span class="line">        right_wait += arr[j];</span><br><span class="line">        <span class="keyword">if</span> (right_wait &gt; right_sum) &#123; right_sum = right_wait; lr_end = j; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lr_sum = right_sum + left_sum;</span><br><span class="line">    <span class="type">int</span> MAX;</span><br><span class="line">    <span class="keyword">if</span> (lr_sum &gt; Max_left_sum &amp;&amp; lr_sum &gt; Max_right_sum) &#123; start1 = lr_start; end1 = lr_end; MAX = lr_sum; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Max_left_sum &gt; lr_sum &amp;&amp; Max_left_sum &gt; Max_right_sum) &#123; start1 = left_start; end1 = left_end; MAX = Max_left_sum; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; start1 = right_start; end1 = right_end; MAX = Max_right_sum; &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSubSeqSum_Divide_Conquer</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> size, <span class="type">int</span>&amp; start, <span class="type">int</span>&amp; end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*Implement the function body below.</span></span><br><span class="line"><span class="comment">    max_start and max_end are used to return the start and end index of the max subsequence found by the algorithm*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max_Divden</span>(arr, <span class="number">0</span>, size, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-Algorithm-analysis"><a href="#2-4-Algorithm-analysis" class="headerlink" title="2.4 Algorithm analysis"></a>2.4 Algorithm analysis</h6><p>如果你能看懂<a href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%AE%97%E6%B3%95">2.2</a>那你应该能看出来分而治之的真实含义，其实每一次执行一次迭代都是从原来的序列的中间部分展开来分成了两个子序列再继续执行。所以对于一个规模为N的一个序列，我们用分而治之的方法就相当于将它拆成了两个子问题，然后两个子问题自己又会分别拆成两个子问题直到最后分到只剩下一个元素，然后将相关的值返回。</p>
<p>所以问题规模为N的问题的时间复杂度为$T(N)$&#x3D;:<br>$$<br>\begin{cases}<br>T(1)&#x3D;1\<br>T(N)&#x3D;2T(N&#x2F;2)+N\<br>\end{cases}<br>$$<br>里面的“$+N$”是怎么来的？在Max_Divden()中我们能看到在将原问题拆分成两个子问题后，我们的程序将会去计算cross_max_sum， 它将会从左和从右分别算出两个最大的sum然后相加，这面最坏的情况就是每一个元素都要加上，如果是这样的话，这些代码的时间复杂度就为$O(N)$（因为一个是从0加到N&#x2F;2, 另一个是从N&#x2F;2+1加到N， 所以合起来就是要执行N次， 两个for循环一起接触到了子数组的每一个元素）， 然后这里我们简化成为$N$。</p>
<p>最后我们将$T(N)$化简：<br>$$<br>T(N)&#x3D;2T(N&#x2F;2)+N;\<br>T(N)&#x3D;4T(N&#x2F;4)+2N;\<br>&#x3D;…\<br>T(N)&#x3D;2^kT(N&#x2F;2^k)+kN;\<br>With,k&#x3D;logN, we,have:\<br>T(N)&#x3D;NT(1)+NlogN\<br>T(N)&#x3D;NlogN+N\<br>$$<br>最后$T(N)&#x3D;O(NlogN);$</p>
<h2 id="5-Sort"><a href="#5-Sort" class="headerlink" title="5. Sort"></a>5. Sort</h2><h3 id="5-1-Bubble-Sort"><a href="#5-1-Bubble-Sort" class="headerlink" title="5.1 Bubble Sort()"></a>5.1 Bubble Sort()</h3><h4 id="1-Code"><a href="#1-Code" class="headerlink" title="1. Code"></a>1. Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sorting::BubbleSort</span><span class="params">(<span class="type">int</span>* NumList)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num<span class="number">-1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num<span class="number">-1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (NumList[j] &gt; NumList[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = NumList[j];</span><br><span class="line">                NumList[j] = NumList[j + <span class="number">1</span>];</span><br><span class="line">                NumList[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-The-process"><a href="#2-The-process" class="headerlink" title="2. The process"></a>2. The process</h4><p><img src="https://img-blog.csdnimg.cn/00fd68be8a684e64bb17f8f140ad53d4.gif#pic_center" alt="在这里插入图片描述"></p>
<p>  According to the code and the picture, you may understand the process of the “Bubble sort”. First of all,    from the picture we can easily know that the whole function will at least do through n times then it may be sorted. So that, for the first for loop it may go n times. And in the second for loop, it will go to N-1 times to compare the num[j] and num[j+1] (前一个和后一个两两比较), then if the former is larger than the latter, the swap them. So that from the picture you can know that every time, the “largest” in the surplus sequence will be put the suitable position(其实就是说剩余序列里面最大那个数据最终会排在剩下的序列里面的最后的位置，最后，整个序列就会以一个升序的序列排好。).</p>
<p>1&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2&gt;每趟从第一对相邻元素开始，对每一对相邻元素作同样的工作，直到最后一对。<br>3&gt;针对所有的元素重复以上的步骤，除了已排序过的元素(每趟排序后的最后一个元素)，直到没有任何一对数字需要比较。 </p>
<h4 id="3-Time-complexity"><a href="#3-Time-complexity" class="headerlink" title="3. Time complexity"></a>3. Time complexity</h4><p>冒泡排序的时间复杂度：每一次外部循环中内部循环次数的和。</p>
<p>$T(N)&#x3D;N+(N-1)+(N-2)+···+1;$</p>
<p>$T(N)&#x3D;\sum_{i&#x3D;1}^{N}1&#x3D;(1+N)*N&#x2F;2&#x3D;O(N^2)$</p>
<p>It is the worst case. But actually, there is a improved code of the Bubble sort, which time complexity is $O(N)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &gt;= length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = length<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--, flag = <span class="number">1</span>)&#123; </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp        = array[j];</span><br><span class="line">                array[j]   = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;<span class="comment">//https://blog.csdn.net/weixin_43419883/article/details/88418730</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Insertion-Sort"><a href="#5-2-Insertion-Sort" class="headerlink" title="5.2 Insertion Sort()"></a>5.2 Insertion Sort()</h3><h4 id="1-Code-1"><a href="#1-Code-1" class="headerlink" title="1. Code"></a>1. Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sorting::InsertSort</span><span class="params">(<span class="type">int</span>* NumList)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="type">int</span> compare = NumList[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; compare &lt; NumList[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            NumList[j] = NumList[j - <span class="number">1</span>];</span><br><span class="line">            NumList[j - <span class="number">1</span>] = compare;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Process"><a href="#2-Process" class="headerlink" title="2. Process"></a>2. Process</h4><p><img src="https://img-blog.csdnimg.cn/9b7a4317cbd644acb081bb7141f4c23c.gif#pic_center" alt="在这里插入图片描述"></p>
<p>  插入排序的思想是： 将初始数据分为有序部分和无序部分，每一步将一个无序部分的数据插入到前面已经排好序的部分中，直到插完所有元素为止。</p>
<p>  每次从无序部分中取出一个元素，与有序部分中的元素从后向前依次进行比较，并找到合适的位置，将该元素插到有序组当中。可以看看图例。</p>
<h4 id="3-Time-complexity-1"><a href="#3-Time-complexity-1" class="headerlink" title="3. Time complexity"></a>3. Time complexity</h4><p>The worst case : 最坏的情况跟冒泡排序差不多: Inner loop is executed p times, fr each p&#x3D; 1,2,…,N-1;</p>
<p>再加上外层循环： $T(N)&#x3D;+2+3+4+···+N&#x3D;O(N^2)$;</p>
<p>The best case:</p>
<ul>
<li>The input is already sorted in increasing order<br>    -  When inserting $A[p]$ into the sorted $A[0,..,p-1]$, only  need to compare $A[p]$ with $A[p-1]$ and there is no data  movement.<br>          -   For each iteration of the outer for-loop, the inner for loop terminates after checking the loop condition once  $\geq O(N)$ time.<br>- If input is &#x3D;&#x3D;nearly sorted&#x3D;&#x3D;, insertion sort runs fast.</li>
</ul>
<h3 id="5-3-Merge-Sort"><a href="#5-3-Merge-Sort" class="headerlink" title="5.3 Merge Sort()"></a>5.3 Merge Sort()</h3><h4 id="1-Code-2"><a href="#1-Code-2" class="headerlink" title="1. Code"></a>1. Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Merge two sorted array. Used in MergeSort*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="type">int</span>  left = mid - start + <span class="number">1</span>, right = end - mid;</span><br><span class="line">    <span class="comment">// Create sub arrays to store the old elements.</span></span><br><span class="line">    <span class="type">int</span>* sub_left = <span class="keyword">new</span> <span class="type">int</span>[left];  <span class="type">int</span>* sub_right = <span class="keyword">new</span> <span class="type">int</span>[right];</span><br><span class="line">    <span class="comment">//Put the original data from NumList(the same position) into the temp arrays  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left; i++) &#123; sub_left[i] = NumList[start + i]; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; right; j++)&#123;sub_right[j] = NumList[mid + <span class="number">1</span> + j];&#125;</span><br><span class="line">    <span class="type">int</span> new_left = <span class="number">0</span>, new_right = <span class="number">0</span>; <span class="comment">// Initial index of sub_left and sub_right</span></span><br><span class="line">    <span class="type">int</span> Merge_position = start; <span class="comment">// Initial index of merged array</span></span><br><span class="line">    <span class="comment">//Actually every call of the Merge function is not start from the &quot;0&quot;, the &quot;start&quot; values are different in different calls;  </span></span><br><span class="line">    <span class="comment">// Merge the temp arrays back into array[left..right]</span></span><br><span class="line">    <span class="keyword">while</span> (new_left &lt; left &amp;&amp; new_right &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sub_left[new_left] &lt;= sub_right[new_right]) &#123;</span><br><span class="line">            NumList[Merge_position++] = sub_left[new_left++];<span class="comment">//don&#x27;t froget update the index of the sub array</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;NumList[Merge_position++] = sub_right[new_right++];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//When the first while loop finished, the left and right may have some value in the sub array not merge into the NumList</span></span><br><span class="line">    <span class="comment">//And since the index of subarray is update in the first loop, so it can be a condition to check whether the value in the sub array </span></span><br><span class="line">    <span class="comment">//And if the value is not all take back from the new, we will go into the two while loop below</span></span><br><span class="line">     <span class="keyword">while</span> (new_left &lt; left) &#123; NumList[Merge_position++] = sub_left[new_left++]; &#125;</span><br><span class="line">     <span class="keyword">while</span> (new_right &lt; right) &#123; NumList[Merge_position++] = sub_right[new_right++];&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sorting::MergeSort</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> midpoint = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(NumList, start, midpoint);</span><br><span class="line">    <span class="built_in">MergeSort</span>(NumList, midpoint + <span class="number">1</span>, end); </span><br><span class="line">    <span class="built_in">Merge</span>(NumList, start, midpoint, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Process-1"><a href="#2-Process-1" class="headerlink" title="2. Process"></a>2. Process</h4><p><img src="https://img-blog.csdnimg.cn/270ef9523a2c480687600441ff86ddcc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-Time-complexity-2"><a href="#3-Time-complexity-2" class="headerlink" title="3. Time complexity"></a>3. Time complexity</h4><p>Actually in my perspective, you can treat this like the [“Divide and Conquer”](#Divide and Conquer) . </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sorting::MergeSort</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">  <span class="number">1</span>  <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">  <span class="number">2</span>  <span class="type">int</span> midpoint = (start + end) / <span class="number">2</span>;</span><br><span class="line">  <span class="number">3</span>  <span class="built_in">MergeSort</span>(NumList, start, midpoint);</span><br><span class="line">  <span class="number">4</span>  <span class="built_in">MergeSort</span>(NumList, midpoint + <span class="number">1</span>, end); </span><br><span class="line">  <span class="number">5</span>  <span class="built_in">Merge</span>(NumList, start, midpoint, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  In the “MergeSort()” we can see that it is very similar to the “Divide and Conquer”, in the code we can see that:</p>
<p>  For the line 1, actually every time the if will run, but only when the condition in it is true the <strong>“return”</strong> will run. And when the condition is true, which is $T(1)$, you may say that $T(1)&#x3D;2$, because of the **if ** and <strong>return</strong>, both of them are run, but from the book: &#x3D;&#x3D;”we choose $T(1)&#x3D;1$”&#x3D;&#x3D;, since the constant is not affect the whole time the code will spend;<img src="https://img-blog.csdnimg.cn/f836c1827299424b85d085abecb28069.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p>  And for the line 2—-the divide step, it’s $O(1)$ time(意思是走常数次);</p>
<p>  For the “Conquer step”: After we divide the original array, then the sub array should continue divide until catch the “if” condition. And to complete this part, we should do the divide step two times, just the operation of line 3 and line 4. And since we divide the original from the midpoint, the line 3&amp;4 will spend the same time which equal to $T(N&#x2F;2).$</p>
<p>  Finally for the “Combine step”, here I will show the pseudo-code of the “Merge()” function:</p>
<p><img src="https://img-blog.csdnimg.cn/cb5bf97800b54c28b12ea71d78e85fe5.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p> 与前面的分而治之类似，我们在这里要比较左右两个subsequence的相同位置的element后，根据比较的结果修正原sequence的element的位置，所以我们肯定要遍历到每一个element，所以时间复杂度为$O(N)$. 我们在这里简化为$N$.<br>$$<br>\begin{cases}<br>T(1)&#x3D;1\T(N)&#x3D;2T(N&#x2F;2)+N\<br>\end{cases}<br>$$</p>
<p>$$<br>T(N)&#x3D;2T(N&#x2F;2)+N;\<br>T(N)&#x3D;4T(N&#x2F;4)+2N;\<br>&#x3D;…\<br>T(N)&#x3D;2^kT(N&#x2F;2^k)+kN;\<br>With,k&#x3D;logN, we,have:\<br>T(N)&#x3D;NT(1)+NlogN\<br>T(N)&#x3D;NlogN+N\<br>$$</p>
<p>So that $T(N)&#x3D;O(NlogN)$.</p>
<h3 id="5-4-Quick-Sort"><a href="#5-4-Quick-Sort" class="headerlink" title="5.4 Quick Sort()"></a>5.4 Quick Sort()</h3><h4 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h4><ul>
<li><p>&#x3D;&#x3D;Fastest&#x3D;&#x3D; known sorting algorithm in practice;</p>
</li>
<li><p>Average case: $O(NlogN)$; </p>
</li>
<li><p>Worst case: $O(N^2)$;</p>
<ul>
<li>But, the worst case seldom happens.</li>
</ul>
</li>
<li><p>Another divide-and-conquer recursive algorithm,     like merge-sort.<br><img src="https://img-blog.csdnimg.cn/571736a1de064127a9f276f21922d513.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="2-Code"><a href="#2-Code" class="headerlink" title="2. Code"></a>2. Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="type">int</span> temp = NumList[i];</span><br><span class="line">    NumList[i] = NumList[j];</span><br><span class="line">    NumList[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MedianOfThree</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> begin, <span class="type">int</span> tail)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="type">int</span>  center = (begin + tail) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (NumList[center] &lt; NumList[begin]) &#123; <span class="built_in">Swap</span>(NumList, begin, center); &#125;</span><br><span class="line">    <span class="keyword">if</span> (NumList[tail] &lt; NumList[begin]) &#123; <span class="built_in">Swap</span>(NumList, begin, tail); &#125;</span><br><span class="line">    <span class="keyword">if</span> (NumList[tail] &lt; NumList[center]) &#123; <span class="built_in">Swap</span>(NumList, center, tail); &#125;</span><br><span class="line">    <span class="built_in">Swap</span>(NumList, center, tail - <span class="number">1</span>);<span class="comment">//After compare the begin, center, tail and the sawp, the center is the pivot we choose, then swap it with the end-1 element.</span></span><br><span class="line">    <span class="keyword">return</span> NumList[tail - <span class="number">1</span>];<span class="comment">//return the pivot back</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> begin, <span class="type">int</span> tail)</span></span>&#123;  </span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;here&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">MedianOfThree</span>(NumList, begin, tail);</span><br><span class="line">    <span class="type">int</span> i = begin - <span class="number">1</span>; <span class="type">int</span> j = tail - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//the update and the stop conditions are in the for loop function </span></span><br><span class="line">       <span class="comment">// cout &lt;&lt; &quot;here1&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (NumList[++i] &lt; pivot) &#123;  &#125;</span><br><span class="line">        <span class="keyword">while</span> (pivot &lt; NumList[--j]) &#123;  &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123; <span class="built_in">Swap</span>(NumList, i, j); &#125;<span class="comment">//this step is begin after the two while loop, if the &quot;i&quot; still smaller than the &quot;j&quot;, which mean that the element between the position &quot;i&quot; and &quot;j&quot; haven not is not &lt;=pivot or &gt;=pivot,so we go into the if step.</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Swap</span>(NumList, i, tail - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sorting::QuickSort</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> begin, <span class="type">int</span> tail)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Write your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (begin &lt; tail) &#123;</span><br><span class="line">        <span class="type">int</span> partition = <span class="built_in">Partition</span>(NumList, begin, tail);</span><br><span class="line">        <span class="built_in">QuickSort</span>(NumList, begin, partition - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(NumList, partition + <span class="number">1</span>, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Idea"><a href="#3-Idea" class="headerlink" title="3. Idea"></a>3. Idea</h4><h5 id="3-1-Partitioning"><a href="#3-1-Partitioning" class="headerlink" title="3.1 Partitioning"></a>3.1 Partitioning</h5><ul>
<li>This is a &#x3D;&#x3D;<strong>key step</strong>&#x3D;&#x3D; of the quick sort algorithm.</li>
<li>&#x3D;&#x3D;Goal&#x3D;&#x3D;: given the picked pivot, partition the  remaining elements into two smaller sets. </li>
<li>Many ways to implement how to partition: </li>
<li>Even the slightest deviations may cause  surprisingly bad results.</li>
</ul>
<h5 id="3-2-Partitioning-Strategy"><a href="#3-2-Partitioning-Strategy" class="headerlink" title="3.2 Partitioning Strategy"></a>3.2 Partitioning Strategy</h5><p><img src="https://img-blog.csdnimg.cn/5664ad19729b4215aad98e9843ef847c.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/347634de29ce409abb77432bed8cef0b.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/290db96f0480400ea5bef2ba92b4cb3c.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fd056483c5194884ba77ce093bacf15d.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-3-Picking-the-Pivot"><a href="#3-3-Picking-the-Pivot" class="headerlink" title="3.3 Picking the Pivot"></a>3.3 Picking the Pivot</h5><ul>
<li><p>Use the first element as pivot </p>
</li>
<li><p>if the input is random, OK </p>
</li>
<li><p>if the input is presorted (or in reverse order)<br>-  all the elements go into $S_2$ (or $S_1$)<br>-  this happens consistently throughout the recursive calls.<br>- Results in $O(n^2)$ behavior (Analyze this case later) </p>
</li>
<li><p>Choose the pivot randomly.</p>
<ul>
<li>Generally safe.</li>
<li>Random number generation can be expensive.</li>
</ul>
</li>
<li><p>Use the median of the array </p>
</li>
<li><p>Partitioning always cuts the array into roughly half.</p>
</li>
<li><p>An &#x3D;&#x3D;optimal&#x3D;&#x3D; quick sort ($O(N log N)$) . </p>
</li>
<li><p>However, hard to find the exact median<br>-  Sort an array to pick the value in the  middle.</p>
</li>
<li><p><strong>Median of three</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/6d8cc56d8bef44429b1a540e1ecdb82f.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2f59c6ec2c6444a2a3b8ba200a36dff0.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<p> Why we only do the partition $A[left+1,…,right-2]$, actually, the first and the last one we already compare with the pivot, the position they are is already smaller or larger than the pivot. So after we collect the pivot, we only need partition the element between the $left+1 ,and ,right-2$. </p>
<p><img src="https://img-blog.csdnimg.cn/5b69825999f64c92ac4843f25db02f0d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4ddc5e79977240cf9e193a3d34ca57e6.gif#pic_center" alt="在这里插入图片描述"></p>
<h4 id="4-Time-complexity"><a href="#4-Time-complexity" class="headerlink" title="4. Time complexity"></a>4. Time complexity</h4><p> Like mergesort, quicksort is recursive; therefore, its analysis requires solving a recurrence formula. We will do the analysis for a quicksort, assuming a random pivot (no medianof-three partitioning) and no cutoff for small arrays. We will take $T(0) &#x3D; T(1) &#x3D; 1$, as in mergesort. The running time of quicksort is equal to the running time of the two recursive calls plus the linear time spent in the partition (the pivot selection takes only constant time). This gives the basic quicksort relation :</p>
<p>$T(N)&#x3D;T(i)+T(N-i-1)+cN$</p>
<p> where $i &#x3D; |S_1|$ is the number of elements in $S_1$. We will look at three cases.</p>
<ul>
<li><p><em><strong>Worst-Case Analysis</strong></em></p>
<p>The pivot is the smallest element, all the time. Then i &#x3D; 0, and if we ignore T(0) &#x3D; 1, which is insignificant, the recurrence is </p>
<p>$T(N) &#x3D; T(N − 1) + cN, N &gt; 1 $;</p>
</li>
</ul>
<p>  $ T(N − 1) &#x3D; T(N − 2) + c(N − 1) \ T(N − 2) &#x3D; T(N − 3) + c(N − 2) \…\ T(2) &#x3D; T(1) + c(2) ;$</p>
<p>   Adding up all these equations yields :</p>
<p>  $T(N)&#x3D;T(1)+c\sum_{i&#x3D;2}^{N}i&#x3D;\Theta(N^2)$;</p>
<p>   as claimed earlier. To see that this is the worst possible case, note that the total cost of all the partitions in recursive calls at depth d must be at most N. Since the recursion depth is at most N, this gives an &#x3D;&#x3D;$O(N^2)$ worst-case&#x3D;&#x3D; bound for quicksort. </p>
<ul>
<li><p><em><strong>Best-Case Analysis</strong></em></p>
<p> In the best case, the pivot is in the middle. To simplify the math, we assume that the two subarrays are each exactly half the size of the original, and although this gives a slight overestimate, this is acceptable because we are only interested in a Big-Oh answer :</p>
<p> $T(N) &#x3D; 2T(N&#x2F;2) + cN $                         (1)</p>
<p>  Divide both sides of Equation (1) by $N$</p>
<p> $T(N) &#x2F;N &#x3D; T(N&#x2F;2)&#x2F;(N&#x2F;2) + c $                   (2)  </p>
<p> We will telescope using this equation: </p>
<p>$T(N&#x2F;2)&#x2F;(N&#x2F;2)&#x3D;T(N&#x2F;4)&#x2F;(N&#x2F;4)+c;$</p>
<p>$T(N&#x2F;4)&#x2F;(N&#x2F;4)&#x3D;T(N&#x2F;8)&#x2F;(N&#x2F;8)+c;$</p>
<p>$…$</p>
<p>$T(2)&#x2F;2&#x3D;T(1)&#x2F;1+c$;</p>
<p>Add them up</p>
<p>$T(N)&#x3D;cNlogN+N&#x3D;\Theta(NlogN)$;</p>
<p> Notice that this is the exact same analysis as mergesort; hence, we get the same answer. </p>
</li>
<li><p><em><strong>Average-Case Analysis</strong></em></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/369290515656436a8659e07fd5587886.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0a8dba9e26774344a2a5e6cf92bd1e51.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>Small Arrays</strong></p>
<p> For very small arrays $(N ≤ 20)$, quicksort does not perform as well as insertion sort. Furthermore, because quicksort is recursive, these cases will occur frequently. A common solution is not to use quicksort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays, such as insertion sort. Using this strategy can actually save about 15 percent in the running time (over doing no cutoff at all). A good cutoff range is $N &#x3D; 10$, although any cutoff between 5 and 20 is likely to produce similar results. This also saves nasty degenerate cases, such as taking the median of three elements when there are only one or two.</p>
</li>
</ul>
<h3 id="5-5-Heap-Sort"><a href="#5-5-Heap-Sort" class="headerlink" title="5.5 Heap Sort()"></a>5.5 Heap Sort()</h3><h4 id="1-Background-Binary-Trees"><a href="#1-Background-Binary-Trees" class="headerlink" title="1. Background: Binary Trees"></a>1. Background: Binary Trees</h4><ul>
<li><p>Has a &#x3D;&#x3D;root&#x3D;&#x3D; at the topmost  level. </p>
</li>
<li><p>Each &#x3D;&#x3D;node&#x3D;&#x3D; has &#x3D;&#x3D;zero, one or  two children&#x3D;&#x3D;.</p>
</li>
<li><p>A node that has &#x3D;&#x3D;no child&#x3D;&#x3D; is  called a &#x3D;&#x3D;leaf&#x3D;&#x3D;. </p>
</li>
<li><p>For a node x, we denote the  left child, right child and the  parent of x as left(x),  right(x) and parent(x),  respectively.</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/a7bf1d84840a4b42878116a75f7b7a00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><em><strong>Height (Depth) of a Binary Tree</strong></em> :The number of &#x3D;&#x3D;edges&#x3D;&#x3D; on the &#x3D;&#x3D;longest&#x3D;&#x3D; path from the root to a leaf.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bc87253d88b7485bb6f2144a747454c9.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-Background-Complete-Binary-Trees"><a href="#2-Background-Complete-Binary-Trees" class="headerlink" title="2. Background: Complete Binary Trees"></a>2. Background: Complete Binary Trees</h4><ul>
<li>A &#x3D;&#x3D;complete binary tree&#x3D;&#x3D; is the tree.</li>
<li>Where a node can have 0 (for the leaves) or 2 children. </li>
<li>&#x3D;&#x3D;All leaves are at the same depth&#x3D;&#x3D;. </li>
<li>No. of nodes and height </li>
<li>A complete binary tree with &#x3D;&#x3D;N nodes has height $O(logN)$&#x3D;&#x3D;.</li>
<li>A complete binary tree with &#x3D;&#x3D;height d has $2^{d+1}-1$ nodes&#x3D;&#x3D;.<br>  <img src="https://img-blog.csdnimg.cn/4aa13294f8594feaa922eea545959da8.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/654da24fdf4c4b3dbe8e8d2aa0088bac.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/f3094c8c962d46568c45ce8c68370711.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/ea8e1aa9a9d446eab19b0356848f4b4e.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  <img src="https://img-blog.csdnimg.cn/faa04d48be1b4ef6b48fc66f005a5250.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_ZnJvbSBSaWNrMnBj,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p>   The property that allows operations to be performed quickly is the heap-order property. Since we want to be able to find the minimum quickly, it makes sense that the smallest element should be at the root. If we consider that any subtree should also be a heap, then any node should be smaller than all of its descendants.   Applying this logic, we arrive at the heap-order property. In a heap, for every node X, the key in the parent of X is smaller than (or equal to) the key in X, with the exception of the root (which has no parent).2 In Figure 6.5 the tree on the left is a heap, but the tree on the right is not (the dashed line shows the violation of heap order). By the heap-order property, the minimum element can always be found at the root. Thus, we get the extra operation, <strong>findMin</strong>, in constant time. </p>
<h4 id="3-Code"><a href="#3-Code" class="headerlink" title="3.  Code"></a>3.  Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the children is smaller than the parent</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateUp</span><span class="params">(<span class="type">int</span>* heap, <span class="type">int</span> currentSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentSize == <span class="number">1</span>) &#123; heap[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="type">int</span> i = currentSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = (i) / <span class="number">2</span>; (j &gt; <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) &amp;&amp; heap[i] &gt; heap[j]; i = j, j = (i) / <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">Swap</span>(heap, i, j);<span class="comment">//due to the calculation in the c++, never mind the left and the right child, atually just think about the parent.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this step is compare the child with parent, if child larger than Swap child and the parent to build a max-heap.</span></span><br><span class="line"><span class="comment">/**Append an element to the end of heap, and adjust heap to maintain the max-heap order.*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHeap</span><span class="params">(<span class="type">int</span>* heap, <span class="type">int</span>&amp; currentSize, <span class="type">const</span> <span class="type">int</span> ele)</span></span>&#123;</span><br><span class="line">    heap[++currentSize] = ele;</span><br><span class="line">    <span class="built_in">percolateUp</span>(heap, currentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Construct a max heap (Parent larger than its children)*/</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* heap = <span class="keyword">new</span> <span class="type">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> currentSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        <span class="built_in">InsertHeap</span>(heap, currentSize, NumList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Adjust heap to maintain the heap order*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span>* MaxHeap, <span class="type">int</span> currentSize)</span></span>&#123;   <span class="comment">//the opposite usage to the percolateUP</span></span><br><span class="line">    <span class="keyword">if</span> (currentSize &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MaxHeap[<span class="number">1</span>] &gt; MaxHeap[<span class="number">2</span>]) &#123; <span class="built_in">Swap</span>(MaxHeap, <span class="number">1</span>, <span class="number">2</span>); &#125;<span class="comment">//To help the for loop. Due to some reason from the for loop</span></span><br><span class="line">    &#125;                                                       <span class="comment">//for some cases, the  MaxHeap[1] &gt; MaxHeap[2], so I add one step here to complete.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">2</span> * i, r = <span class="number">2</span> * i + <span class="number">1</span>; (i &lt; currentSize &amp;&amp; l &lt; currentSize &amp;&amp; r &lt; currentSize) &amp;&amp; (MaxHeap[i] &lt; MaxHeap[l] || MaxHeap[i] &lt; MaxHeap[r]); ) &#123;<span class="comment">//some problrm inthe part of the i,j,h update comditions.</span></span><br><span class="line">        <span class="keyword">if</span> (MaxHeap[i] &lt; MaxHeap[l] &amp;&amp; MaxHeap[i] &lt; MaxHeap[r]) &#123;</span><br><span class="line">            <span class="comment">//MaxHeap[l] &gt; MaxHeap[r] ? Swap(MaxHeap, i, l) : Swap(MaxHeap, i, r);</span></span><br><span class="line">            <span class="keyword">if</span> (MaxHeap[l] &gt; MaxHeap[r]) &#123; <span class="built_in">Swap</span>(MaxHeap, i, l); i = l; l = <span class="number">2</span> * i; r = l + <span class="number">1</span>; &#125;<span class="comment">//There is interesting, remember that due to the left and the right children, the update function is different in once loop.</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="built_in">Swap</span>(MaxHeap, i, r); i = r; l = <span class="number">2</span> * i; r = l + <span class="number">1</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (MaxHeap[i] &lt; MaxHeap[l]) &#123; <span class="built_in">Swap</span>(MaxHeap, i, l); i = l; l = <span class="number">2</span> * i; r = l + <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="built_in">Swap</span>(MaxHeap, i, r); i = r; l = <span class="number">2</span> * i; r = l + <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Save the max (top of the heap) element M</span></span><br><span class="line"><span class="comment">2. Move MaxHeap[currentSize] to the top</span></span><br><span class="line"><span class="comment">3. Call percolateDown() to maintain the max-heap order</span></span><br><span class="line"><span class="comment">4. Save &quot;M&quot; to MaxHeap[currentSize]</span></span><br><span class="line"><span class="comment">5. currentSize--*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMin</span><span class="params">(<span class="type">int</span>* MaxHeap, <span class="type">int</span>&amp; currentSize)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Swap</span>(MaxHeap, <span class="number">1</span>, currentSize);<span class="comment">//Actually I directly use the Swap function in the Quick sort, same usage like the reference above. Every time i change the first element and the end--.</span></span><br><span class="line">    <span class="built_in">percolateDown</span>(MaxHeap, currentSize);</span><br><span class="line">    currentSize--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Sorting::HeapSort</span><span class="params">(<span class="type">int</span>* NumList)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* MaxHeap = <span class="built_in">BuildMaxHeap</span>(NumList, num); <span class="comment">//Construct the max-heap;</span></span><br><span class="line">    <span class="type">int</span> currentSize = num;</span><br><span class="line">    <span class="keyword">while</span>(currentSize&gt;<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">DeleteMin</span>(MaxHeap, currentSize);</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; num; i++) &#123; cout &lt;&lt; MaxHeap[i] &lt;&lt; &quot; &quot;; &#125;cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//After the while loop, the original MaxHeap array becomes a ascending-sorted array.</span></span><br><span class="line">    <span class="keyword">return</span> MaxHeap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The answer of the lab</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">**Maintain max-heap order*/</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateUp</span><span class="params">(<span class="type">int</span>* heap, <span class="type">int</span> currentSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = currentSize;</span><br><span class="line">    <span class="keyword">while</span> (idx &gt; <span class="number">1</span> &amp;&amp; heap[idx] &gt; heap[idx / <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[idx], heap[idx / <span class="number">2</span>]);</span><br><span class="line">        idx = idx / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Append an element to the end of heap, and adjust heap to maintain the max-heap order.*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHeap</span><span class="params">(<span class="type">int</span>* heap, <span class="type">int</span>&amp; currentSize, <span class="type">const</span> <span class="type">int</span> ele)</span></span>&#123;</span><br><span class="line">    heap[++currentSize] = ele;</span><br><span class="line">    <span class="built_in">percolateUp</span>(heap, currentSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Construct a max heap (Parent larger than its children)*/</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span>* NumList, <span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* heap = <span class="keyword">new</span> <span class="type">int</span>[num+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> currentSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        <span class="built_in">InsertHeap</span>(heap, currentSize, NumList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**Adjust heap to maintain the heap order*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">(<span class="type">int</span>* MaxHeap, <span class="type">int</span> currentSize)</span></span>&#123;   </span><br><span class="line">    <span class="type">int</span> hole = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> tmp = MaxHeap[hole];</span><br><span class="line">    <span class="keyword">while</span> (hole * <span class="number">2</span> &lt; currentSize) &#123;</span><br><span class="line">        <span class="type">int</span> child = hole * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (MaxHeap[child] &lt; MaxHeap[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child = child + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (MaxHeap[child] &gt; tmp) &#123;</span><br><span class="line">            MaxHeap[hole] = MaxHeap[child];</span><br><span class="line">            hole = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxHeap[hole] = tmp; <span class="comment">// Move the top (max) element to the end of heap;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. Save the max (top of the heap) element M</span></span><br><span class="line"><span class="comment">2. Move MaxHeap[currentSize] to the top</span></span><br><span class="line"><span class="comment">3. Call percolateDown() to maintain the max-heap order</span></span><br><span class="line"><span class="comment">4. Save &quot;M&quot; to MaxHeap[currentSize]</span></span><br><span class="line"><span class="comment">5. currentSize--*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteMin</span><span class="params">(<span class="type">int</span>* MaxHeap, <span class="type">int</span>&amp; currentSize)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max = MaxHeap[<span class="number">1</span>]; <span class="comment">//Save the top(Max) element.</span></span><br><span class="line">    MaxHeap[<span class="number">1</span>] = MaxHeap[currentSize];  <span class="comment">//Move the end element of MaxHeap to the top;</span></span><br><span class="line">    <span class="built_in">percolateDown</span>(MaxHeap, currentSize);  <span class="comment">//Adjust MaxHeap to maintain the heap structure.</span></span><br><span class="line">    MaxHeap[currentSize] = max; <span class="comment">//Append the previous top element to the end of heap;</span></span><br><span class="line">    currentSize--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Sorting::HeapSort</span><span class="params">(<span class="type">int</span>* NumList)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span>* MaxHeap = <span class="built_in">BuildMaxHeap</span>(NumList, num); <span class="comment">//Construct the max-heap;</span></span><br><span class="line">    <span class="type">int</span> currentSize = num;</span><br><span class="line">    <span class="keyword">while</span>(currentSize&gt;<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">DeleteMin</span>(MaxHeap, currentSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//After the while loop, the original MaxHeap array becomes a ascending-sorted array.</span></span><br><span class="line">    <span class="keyword">return</span> MaxHeap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Trees"><a href="#6-Trees" class="headerlink" title="6. Trees"></a>6. Trees</h2><h3 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h3><ul>
<li>A &#x3D;&#x3D;tree&#x3D;&#x3D; is a collection of nodes<ul>
<li>The collection can be empty;</li>
<li>(Recursive Definition) If not empty, a tree consists of a distinguished node $r$ (the &#x3D;&#x3D;root&#x3D;&#x3D;), and &#x3D;&#x3D;zero or more&#x3D;&#x3D; nonempty &#x3D;&#x3D;subtrees&#x3D;&#x3D; $T_1, T_2, …, T_k$, each of whose roots are connected by a directed &#x3D;&#x3D;edge&#x3D;&#x3D; from r;</li>
</ul>
</li>
<li>&#x3D;&#x3D;Child&#x3D;&#x3D; and &#x3D;&#x3D;Parent&#x3D;&#x3D;<ul>
<li>Every node expect the root has one parent;</li>
<li>A node can have an zero or more children</li>
</ul>
</li>
<li>&#x3D;&#x3D;Leaves&#x3D;&#x3D;<ul>
<li>Leaves are nodes with no children</li>
</ul>
</li>
<li>&#x3D;&#x3D;Sibling&#x3D;&#x3D;<ul>
<li>nodes with same parent</li>
</ul>
</li>
<li>&#x3D;&#x3D;Path&#x3D;&#x3D;<ul>
<li>A path form $n_1 ,to ,n_k$ is defined as a sequence of nodes $n_1,n_2…,n_k$ such that$n_i$ is the parent of $n_{i+1}$ for $1\leq i&lt;k$.</li>
</ul>
</li>
<li>&#x3D;&#x3D;Length&#x3D;&#x3D; of a path<ul>
<li>The length of this path($n_1$ to $n_k$) is the number of edges on the path, namely, $k-1$ .</li>
<li>There is a path of length zero from every node to itself;</li>
<li>Notice that in a tree there is exactly one path from the root to each node.</li>
</ul>
</li>
<li>&#x3D;&#x3D;Depth of a node&#x3D;&#x3D;<ul>
<li>The depth of $n_i$ is the length of the unique path from the root to $n_i$</li>
<li>The root depth is 0</li>
</ul>
</li>
<li>&#x3D;&#x3D;Height of a node&#x3D;&#x3D;<ul>
<li>The height of $n_i$ is the length of the longest path from $n_i$ to a leaf.</li>
<li>All leaves are at height 0;</li>
<li>&#x3D;&#x3D;The height of a tree is equal to the height of the root.&#x3D;&#x3D;</li>
</ul>
</li>
<li>&#x3D;&#x3D;Ancestor&#x3D;&#x3D; and &#x3D;&#x3D;Descendant&#x3D;&#x3D;<ul>
<li>If there is a path from $n_1$ to $n_2$, then $n_1$ is an ancestor pf $n_2$, and $n_2$ is a descendant of $n_1$. If $n_1\neq n_2$， then $n_1$ is a &#x3D;&#x3D;proper ancestor&#x3D;&#x3D;（真祖先）of $n_2$ and $n_2$ is a &#x3D;&#x3D;proper descendant&#x3D;&#x3D;（真后裔）of $n_1$.</li>
</ul>
</li>
</ul>
<h3 id="Tree-Traversals-with-an-Application"><a href="#Tree-Traversals-with-an-Application" class="headerlink" title="Tree Traversals with an Application"></a>Tree Traversals with an Application</h3><p>Example tree:</p>
<p><img src="https://img-blog.csdnimg.cn/d0ee85ae1a094daf94884133d50c714f.bmp" alt="请添加图片描述"></p>
<p>  图4.14显示的是一个&#x3D;&#x3D;表达式树(expression tree)&#x3D;&#x3D;的例子。表达树的树叶(leaves)是操作数(operand)， 如常数或变量名字，而其他的节点为操作符(operator)。由于这里所有的操作都是二元（二目）的，因此这棵特定的数正好是二叉树。我们可以通过递归计算左子树和右子树所得到的值应用在根处的运算符上而算出表达式树 $T$ 的值。在我的例子中，左子树为$a+(b<em>c)$ ，右子树的值是$((d</em>e+f)*g)$， 因此整个树表示为$ (a + (b * c)) + (((d * e) + f) * g) $,</p>
<h4 id="1-Preorder-Traversal-先序遍历"><a href="#1-Preorder-Traversal-先序遍历" class="headerlink" title="1. Preorder Traversal(先序遍历)"></a>1. Preorder Traversal(先序遍历)</h4><p>&#x3D;&#x3D;Expression order: $node,\rightarrow,left\rightarrow,right$;&#x3D;&#x3D;</p>
<p>Prefix expression（前缀记法）: $++a<em>bc</em>+*defg$</p>
<p>Pseudo Code:</p>
<p>$Algorithm,Preorder(x)\Input:,x,is,the ,root,of,a,subtree\1. if,x\neq,NULL\2.then,output ,key(x);\3.Preorder(left(x));\4.Preorder(right(x));$</p>
<p>Time Complexity: $O(n)$;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::PreTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Fill the code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">char</span>(root-&gt;data) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">PreTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-Postorder-Traversal-后序遍历"><a href="#2-Postorder-Traversal-后序遍历" class="headerlink" title="2. Postorder Traversal(后序遍历)"></a>2. Postorder Traversal(后序遍历)</h4><p>&#x3D;&#x3D;Expression order: $left,\rightarrow,right\rightarrow,node$;&#x3D;&#x3D;</p>
<p>Postfix expression(后缀记法):$abc*+de<em>f+g</em>+$</p>
<p>Pseudo Code:</p>
<p>$Algorithm,Postorder(x)\Input:,x,is,the ,root,of,a,subtree\1. if,x\neq,NULL\2.then,Postorder(left(x));\3.Postorder(right(x));\4.output ,key(x);$</p>
<p>Time Complexity: $O(n)$;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::PostTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Fill the code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">PostTraversal</span>(root-&gt;right);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">char</span>(root-&gt;data) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-Inorder-Traversal-中序遍历"><a href="#3-Inorder-Traversal-中序遍历" class="headerlink" title="3. Inorder Traversal(中序遍历)"></a>3. Inorder Traversal(中序遍历)</h4><p>&#x3D;&#x3D;Expression order: $left,\rightarrow,node\rightarrow,right$;&#x3D;&#x3D;</p>
<p>Infix expression(中序记法): $a+b<em>c+d</em>e+f*g$;</p>
<p>Pseudo Code:</p>
<p>$Algorithm,Inorder(x)\Input:,x,is,the ,root,of,a,subtree\1. if,x\neq,NULL\2.then,Inorder(left(x));\3.output ,key(x);\4.Postorder(right(x));$</p>
<p>Time Complexity: $O(n)$;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tree::InTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Fill the code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InTraversal</span>(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">char</span>(root-&gt;data) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">InTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-Binary-Tree"><a href="#6-1-Binary-Tree" class="headerlink" title="6.1 Binary Tree"></a>6.1 Binary Tree</h3><p> A binary tree is a tree in which &#x3D;&#x3D;no node can have more than two children&#x3D;&#x3D;.</p>
<p><img src="https://img-blog.csdnimg.cn/acc904703365406799f51d8f0edd022c.bmp" alt="请添加图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/5e0376d200e0406eb0eddd444cc297a1.bmp" alt="请添加图片描述"></p>
<p> A property of a binary tree that is sometimes important is that the depth of an average binary tree is considerably smaller than N. An analysis shows that the average depth is $O( √N)$, and that for a special type of binary tree, namely the &#x3D;&#x3D;binary search tree&#x3D;&#x3D;, &#x3D;&#x3D;the average value of the depth is $O(logN)$&#x3D;&#x3D;. Unfortunately, the depth can be as large as $N − 1$, as the example in Figure 4.12 shows. </p>
<h4 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h4><p>Property: For every node $X$ , all the keys in its &#x3D;&#x3D;left subtree are smaller&#x3D;&#x3D; than the key value in X, and &#x3D;&#x3D;all the keys in the right subtree are larger&#x3D;&#x3D; than the key value in X.</p>
<p><img src="https://img-blog.csdnimg.cn/98679d2ecf604b2fbd6a258ebf678994.bmp#pic_center" alt="在这里插入图片描述"></p>
<p>The &#x3D;&#x3D;average depth&#x3D;&#x3D; of a (node)binary search tree turns out to be $O(logN)$; and the maximum depth of a node is $O(N) $.</p>
<h4 id="Implementation-of-Binary-Search-Tree"><a href="#Implementation-of-Binary-Search-Tree" class="headerlink" title="Implementation of Binary Search Tree"></a>Implementation of Binary Search Tree</h4><h5 id="1-Construct-BST-and-the-implementation-of-insertion"><a href="#1-Construct-BST-and-the-implementation-of-insertion" class="headerlink" title="1.  Construct BST and the implementation of insertion"></a>1.  Construct BST and the implementation of insertion</h5><p>Construct: 利用insertion来构造BST。</p>
<p>Insertion:</p>
<ul>
<li><p>Proceed down the tree as you would with a find;</p>
</li>
<li><p>If X is found, do nothing (or update something);</p>
</li>
<li><p>Otherwise, insert X at the last spot on the path traversed(将X插入到所遍历的路径的最后一点上)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/439585e7f02d4ea8bd7d21fefce9c8ff.bmp#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Insert node into BST, keeping the BST property. Use the &quot;Insertion&quot; method learned in slide.*/</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">InsertBSTNode</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Input your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;left = root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">//如果root为NULL，那么让root的key的值等于第一个进来的value</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;data) &#123; root-&gt;left = <span class="built_in">InsertBSTNode</span>(root-&gt;left, val); &#125;<span class="comment">//如果进来的value小于root的key值，那么根据BST的特性我们就要将这个value插入到root的左子树里面，至于插到哪一个位置，这里用递归执行继续比较，直到最后可以插入进树中。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;data) &#123; root-&gt;right = <span class="built_in">InsertBSTNode</span>(root-&gt;right, val); &#125;<span class="comment">//和上面的同理</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert each node into BST one by one.</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">ConstructBST</span><span class="params">(<span class="type">int</span>* array, <span class="type">int</span> arrayLength)</span></span>&#123;</span><br><span class="line">	<span class="comment">// Input your code here.</span></span><br><span class="line">    TreeNode* root1=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrayLength; i++) &#123;</span><br><span class="line">        root1=<span class="built_in">InsertBSTNode</span>(root1, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree::<span class="built_in">Tree</span>(<span class="type">int</span>* array, <span class="type">int</span> arrayLength)&#123;</span><br><span class="line">    root = <span class="built_in">ConstructBST</span>(array, arrayLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The time complexity of insertion function is $O(h)$, where $h$ means the height of the tree. Follow the result we discussed above we can know that the the average value of $h$ is $logN$, and the worst case is $N$.</p>
<p>Then the time complexity  of constructing tree is $O(Nlog(N))$. </p>
<h5 id="2-GetMinNode-and-GetMaxNode"><a href="#2-GetMinNode-and-GetMaxNode" class="headerlink" title="2. GetMinNode and GetMaxNode"></a>2. GetMinNode and GetMaxNode</h5><p>Goal: Return the node containing the smallest(largest) key in the tree;</p>
<p>Algorithm: Start at the root and go left(right) as long as there is a left(right) child. The stopping point is the smallest (largest) element.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Tree::getMinNode</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Input your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMinNode</span>(root-&gt;left);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Treeheight"><a href="#3-Treeheight" class="headerlink" title="3. Treeheight"></a>3. Treeheight</h5><ul>
<li>Given a binary tree, find its maximum depth;</li>
<li>The maximum depth is &#x3D;&#x3D;the number of nodes&#x3D;&#x3D; along the longest path from the root node down to the farthest leaf node.（这里的定义和前面的有点不一样）</li>
<li>A leaf is a node with no children.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Tree::TreeHight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TreeHight</span>(root-&gt;left) &gt; <span class="built_in">TreeHight</span>(root-&gt;right) ? <span class="built_in">TreeHight</span>(root-&gt;left) + <span class="number">1</span> : <span class="built_in">TreeHight</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-Height-Balanced"><a href="#4-Height-Balanced" class="headerlink" title="4. Height-Balanced"></a>4. Height-Balanced</h5><p>Determine if a BST is height-balanced. If balance return true, else return false.</p>
<ul>
<li>A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Tree::IsBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Input your code here.</span></span><br><span class="line">    <span class="type">int</span> leftHight;</span><br><span class="line">    <span class="type">int</span> rightHight;</span><br><span class="line">    <span class="comment">/* If tree is empty then return true */</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    leftHight = <span class="built_in">TreeHight</span>(root-&gt;left);</span><br><span class="line">    rightHight = <span class="built_in">TreeHight</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">/* Get the height of left and right sub trees */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHight - rightHight) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">IsBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">IsBalanced</span>(root-&gt;right)) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">/* If we reach here then</span></span><br><span class="line"><span class="comment">    tree is not height-balanced */</span></span><br><span class="line">    <span class="comment">//如果左子树和右子树的高度差的绝对值≤1，并且左右子树也都是平衡树，那么这棵树就是平衡树。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-Deletion"><a href="#5-Deletion" class="headerlink" title="5. Deletion"></a>5. Deletion</h5><p>Deletion is more complex than the other implement, because we should consider how we take care of the children of the deleted node, we should consider following cases:</p>
<ol>
<li><p>The node is a leaf,  then we just delete it immediately;</p>
</li>
<li><p>The node has one child: Adjust a pointer form the parent to bypass that node;</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b203f76f2de04d54ba60ccdd10a9e426.bmp#pic_center" alt="在这里插入图片描述"></p>
<ol start="3">
<li><p>The node has 2 children</p>
<ul>
<li>Replace the key of the node with the minimum element at the right subtree or the maximum element at the left subtree;</li>
<li>Delete the minimum element<ul>
<li>Has either no child or only right child because if it has a left child, that left child would be smaller and would have been chosen. So invoke case 1 or 2.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/45c75e70b2ce4439910f95337d9f4f71.bmp#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Do a binary search. If input value &quot;val&quot; is found in BST, return true, else return false.*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Tree::Search</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Input your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;data) &#123; <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;left, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;data) &#123; <span class="keyword">return</span> <span class="built_in">Search</span>(root-&gt;right, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">Tree::deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="comment">// Input your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Search</span>(root, key)) &#123;</span><br><span class="line">        <span class="comment">// Base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;data &gt; key) &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data &lt; key) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If both children exist</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* PrevNode = root;</span><br><span class="line">            TreeNode* CurrNode = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (CurrNode-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                PrevNode = CurrNode;</span><br><span class="line">                CurrNode = CurrNode-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrevNode != root) &#123;</span><br><span class="line">                PrevNode-&gt;left = CurrNode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                PrevNode-&gt;right = CurrNode-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            root-&gt;data = CurrNode-&gt;data;<span class="comment">// Copy CurrNode Data to root</span></span><br><span class="line">            <span class="keyword">delete</span> CurrNode;</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">// Delete CurrNode and return root</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-1-Balance-Binary-Search-Tree"><a href="#6-1-1-Balance-Binary-Search-Tree" class="headerlink" title="6.1.1 Balance Binary Search Tree"></a>6.1.1 Balance Binary Search Tree</h3><p><img src="https://img-blog.csdnimg.cn/4ca5ac5d562840ebbdbc585b0dddc063.png" alt="请添加图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/b1292a95e5184bf190579795c780877f.png" alt="请添加图片描述"></p>
<h2 id="6-2-AVL-Tree"><a href="#6-2-AVL-Tree" class="headerlink" title="6.2 AVL Tree"></a>6.2 AVL Tree</h2><p> An $AVL$ (Adelson-Velskii and Landis) tree is a binary search tree with a balance condition. The balance condition must be easy to maintain, and it ensures that the depth of the tree is $O(logN)$. </p>
<p> An $AVL$ tree is identical to a binary search tree, except that for every node in the tree, the height of the left and right subtrees can differ by &#x3D;&#x3D;at most 1&#x3D;&#x3D;. (The height of an empty tree is defined to be −1.) (一棵AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树)（空树的高度定义为-1）；</p>
<ul>
<li>Height of subtree: Max # of edges to a leaf</li>
<li>&#x3D;&#x3D;Height of an empty subtree: -1&#x3D;&#x3D;;</li>
<li>Height of one node: 0;</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/64f06e8177e944bcaf22babf78ab4f74.png#pic_center" alt="在这里插入图片描述"></p>
<p>这两幅图中，只有左边的树为$AVL$树，其中，5的左子树的高度为2（左子树的从2到3的高度为2，为最大），4的左子树高度为0,4的右子树的高度为-1.</p>
<ul>
<li>除去可能的插入和删除外，所有的树操作都可以以时间$O(logN)$执行。</li>
</ul>
<h3 id="1-Height-of-AVL-Tree"><a href="#1-Height-of-AVL-Tree" class="headerlink" title="1. Height of $AVL$ Tree"></a>1. Height of $AVL$ Tree</h3><ul>
<li><p>$AVL$ tree with minimum number of nodes</p>
<ul>
<li>在高度为$h$的$AVL$树中，最少点数$S(h)$由$S(h)&#x3D;S(h-1)+S(h-2)+1$给出。</li>
</ul>
<p>Denote $N_h$ the &#x3D;&#x3D;minimum number of nodes&#x3D;&#x3D; in an $AVL$ tree of &#x3D;&#x3D;height h&#x3D;&#x3D;:</p>
</li>
<li><p>Base: $N_0&#x3D;0,,,N_1&#x3D;2$</p>
</li>
<li><p>Recursive relation: $N_h&#x3D;N_{h-1}+N_{h-2}+1$ </p>
<p>$&gt;2N_{h-2}&gt;4N_{h-4}&gt;…&gt;2^iN_{h-2i}$</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f7c33eb045964cb28d8dbd046a11cb59.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-Insertion-in-AVL-tree"><a href="#2-Insertion-in-AVL-tree" class="headerlink" title="2. Insertion in $AVL$ tree"></a>2. Insertion in $AVL$ tree</h3><p>When we do an insertion, we need to update all the balancing information for the nodes on the path back to the root, but the reason that insertion is potentially difficult is that inserting a node could violate the $AVL$ tree property. (For instance, inserting 6 into the $AVL$ tree in Figure 4.32 would destroy the balance condition at the node with key 8.) If this is the case, then the property has to be restored before the insertion step is considered over. It turns out that this can always be done with a simple modification to the tree, known as a &#x3D;&#x3D;<strong>rotation</strong>&#x3D;&#x3D;.</p>
<p>After an insertion, only nodes that are on the path from the insertion point to the root might have their balance altered because only those nodes have their subtrees altered. As we follow the path up to the root and update the balancing information, we may find a node whose new balance violates the $AVL$ condition. We will show how to &#x3D;&#x3D;<strong>rebalance</strong>&#x3D;&#x3D; the tree at the first (i.e., deepest) such node, and we will prove that this rebalancing guarantees that the entire tree satisfies the $AVL$ property.（在一次插入后，只有那些插入点到根节点的路径上的节点的平衡可能被改变，因为只有这些节点的子树可能发生变化。当沿着这条路径上行到根并更新平衡信息时，我们可以发现一个节点，它的新平衡破坏了 $AVL$ 条件。我们将指出如何在第一个这样的节点（即最深的节点）重新平衡这棵树，并证明，这一重新平衡保证整个树满足$AVL$ 性质。）</p>
<ul>
<li>Different Cases for Rebalance<ul>
<li>Denote the &#x3D;&#x3D;node&#x3D;&#x3D; that must be rebalanced $\alpha$:<ul>
<li>Case 1: An insertion into the left subtree of the left child of $\alpha$ ; （对$\alpha$的左儿子的左子树进行一次插值）</li>
<li>Case 2: An insertion into the right subtree of the left child of $\alpha$; （对$\alpha$的左儿子的右子树进行一次插值）</li>
<li>Case 3: An insertion into the left subtree of the right child of $\alpha$;(对$\alpha$的右儿子的左子树进行一次插值)</li>
<li>Case 4: An insertion into the right subtree of the right child $\alpha$;（对$\alpha$的右儿子的右子树进行一次插值）</li>
</ul>
</li>
</ul>
</li>
<li>情形1(2)和4(3)是关于$\alpha$点的镜像对称(mirror image symmetry)。</li>
<li>So that there are actually two kinds of questions:<ul>
<li>Insertion occurs on the <strong>“outside”</strong> (i.e., left-left or right-right) is fixed by &#x3D;&#x3D;single rotation&#x3D;&#x3D; of the tree;</li>
<li>Insertion occurs on the <strong>“inside”</strong> (i.e., left-right or right-left) is fixed by &#x3D;&#x3D;double rotation&#x3D;&#x3D; of the tree;</li>
</ul>
</li>
</ul>
<ul>
<li>Insertion Algorithm:<ul>
<li>Firstly, insert the new key as a new leaf just as in ordinary binary search tree;</li>
<li>Then trace the path &#x3D;&#x3D;from the new leaf towards  the root&#x3D;&#x3D;. For each node x encountered, check if  heights of left(x) and right(x) differ by at most 1.<ul>
<li>If yes, proceed to parent(x);</li>
<li>If not, restructure by doing &#x3D;&#x3D;either a single rotation or  a double rotation&#x3D;&#x3D;.</li>
</ul>
</li>
<li>Note: once we perform a rotation at a node x,  we won’t need to perform any rotation at any  ancestor of x.</li>
</ul>
</li>
</ul>
<h4 id="1-Single-rotation"><a href="#1-Single-rotation" class="headerlink" title="1. Single rotation"></a>1. Single rotation</h4><h5 id="Case-study-Right-rotation"><a href="#Case-study-Right-rotation" class="headerlink" title="Case study: Right rotation"></a>Case study: Right rotation</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::rightRotate</span><span class="params">(TreeNode* curRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Put your code below</span></span><br><span class="line">    TreeNode* Left = curRoot-&gt;left;</span><br><span class="line">    TreeNode* temp = Left-&gt;right;</span><br><span class="line">    Left-&gt;right = curRoot;</span><br><span class="line">    curRoot-&gt;left = temp;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/e1c417e5157e427d8ced5d3740143cd6.png#pic_center" alt="在这里插入图片描述"></p>
<p>It’s case 1, so we need to do right rotation to rebalance the $AVL$ tree.</p>
<p>Here to fit the code, the “curRoot” is $k_2$ and the “Left” is $k_1$ and the “temp” is $Y$.</p>
<p>And here let me show the process of the rotation:</p>
<ul>
<li>In the later code, some functions will call the rightRotate function to do the right rotation;</li>
<li>The in the rightRotate function, we get the curRoot is $k_2$, we have to let the $k_1$ replace the location of $k_2$;</li>
<li>So what have to do is let the right subtree of $k_1$ be $k_2$, so that in the code;</li>
<li>And if there is an original right subtree of $k_1$ we cannot forget it, we should change it to the left subtree of $k_2$.</li>
<li>After that we return left the “Left” node to the location where it call;<ul>
<li>Here you may confused about what if $k_2$ also has parents node?<ul>
<li>Actually that’s the question what I have before. In fact, we return the node back where the function call, there is must a node to accept the return one, actually that node is “$k_2$”, we change the whole “$k_2$” tree outside the whole tree, then we let the “$k_2$” node change the value by $k_1$ (after rotation), then we finish the real replacement part.</li>
<li>中文解释一遍：我们这一段代码你可以看做是从整一棵树里面抽出了那一棵有问题的子树进行修整，但是原本的树还是有问题，我们要将修整好的子树代替坏的子树，但是怎么换呢，我们知道root node相当于一棵树的identity，所以我们只要将修正好的树的root node传回给原本有问题的树的node那么就解决问题了，这里面就不用考虑说“$k_2$”的parent 怎么变换了，因为根本没有涉及。</li>
</ul>
</li>
</ul>
</li>
<li>&#x3D;&#x3D;Time Complexity: $O(1)$.&#x3D;&#x3D;</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/aeea8743785a45b59ec82f18d09c9553.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e7599df327a3411eb0b1ca158c9fa399.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f37442c593124b579879371d04f0922f.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-Double-rotation"><a href="#2-Double-rotation" class="headerlink" title="2. Double rotation"></a>2. Double rotation</h4><p>Actually when we compile the code, we have not write another two functions of Double rotation. The process of implementation is call the single rotation function. </p>
<p><img src="https://img-blog.csdnimg.cn/8fa41fa378894a09b50c82c54f978c32.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0af57764c3c44cf1aef8e610c2ed389d.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>From that we can know that the double rotation have separate into two single rotations:</p>
<ul>
<li>$DLR,(Case,,2),&#x3D;SLR(first ,,operation)+SRR(second,,operation)$ ;</li>
</ul>
<p>​        (Double <strong>Left</strong> rotation, <strong>firstly</strong> single <strong>left</strong> rotation then single right rotation)</p>
<ul>
<li><p>$DRR,(Case,,3),&#x3D;SRR(first ,,operation)+SLR(second,,operation)$.</p>
<p>(Double <strong>right</strong> rotation, <strong>firstly</strong> single <strong>right</strong> rotation then single left rotation)</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/46f97473487b468ea9a0be64431d7cee.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6b61c26b335149088c7c78412fe205dc.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8c835640425e4e60a85fe519735863b0.png#pic_center" alt="在这里插入图片描述"></p>
<p> 最重要的就是判断插入的元素所属的哪个父级出现了unbalance，然后看看是属于那种Case，然后使用相对应的rotation，解决😆😆😆<br><img src="https://img-blog.csdnimg.cn/7963049504544962b6004578f12095ee.gif" alt="在这里插入图片描述"></p>
<h4 id="3-Insertion-code"><a href="#3-Insertion-code" class="headerlink" title="3. Insertion code"></a>3. Insertion code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::rightRotate</span><span class="params">(TreeNode* curRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Put your code below</span></span><br><span class="line">    TreeNode* Left = curRoot-&gt;left;</span><br><span class="line">    TreeNode* temp = Left-&gt;right;</span><br><span class="line">    Left-&gt;right = curRoot;</span><br><span class="line">    curRoot-&gt;left = temp;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::leftRotate</span><span class="params">(TreeNode* curRoot)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Put your code below</span></span><br><span class="line">    TreeNode* Right = curRoot-&gt;right;</span><br><span class="line">    TreeNode* temp = Right-&gt;left;</span><br><span class="line">    Right-&gt;left = curRoot;</span><br><span class="line">    curRoot-&gt;right = temp;</span><br><span class="line">    <span class="keyword">return</span> Right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::insert</span><span class="params">(TreeNode* curRoot, TreeNode* newNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curRoot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        curRoot = newNode;</span><br><span class="line">        <span class="keyword">return</span> curRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Build BST</span></span><br><span class="line">    <span class="keyword">if</span>(newNode-&gt;value &lt; curRoot-&gt;value) &#123;</span><br><span class="line">        curRoot-&gt;left = <span class="built_in">insert</span>(curRoot-&gt;left, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(newNode-&gt;value &gt; curRoot-&gt;value) &#123;</span><br><span class="line">        curRoot-&gt;right = <span class="built_in">insert</span>(curRoot-&gt;right, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No duplicate values allowed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> curRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the tree is balanced</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalanceFator</span>(curRoot);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;Balance = &quot; &lt;&lt; balance &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//Left-Heavy Cases: Right or Left-Right Rotation</span></span><br><span class="line">    <span class="keyword">if</span>(balance &gt; <span class="number">1</span> &amp;&amp; newNode-&gt;value &lt; curRoot-&gt;left-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// Put your code below</span></span><br><span class="line">        curRoot=<span class="built_in">rightRotate</span>(curRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(balance &gt; <span class="number">1</span> &amp;&amp; newNode-&gt;value &gt; curRoot-&gt;left-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// Put your code below</span></span><br><span class="line">        curRoot-&gt;left = <span class="built_in">leftRotate</span>(curRoot-&gt;left);</span><br><span class="line">        curRoot=<span class="built_in">rightRotate</span>(curRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Right-Heavy Cases: Left or Right-Left Rotation</span></span><br><span class="line">    <span class="keyword">if</span>(balance &lt; <span class="number">-1</span> &amp;&amp; newNode-&gt;value &gt; curRoot-&gt;right-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// Put your code below</span></span><br><span class="line">        curRoot=<span class="built_in">leftRotate</span>(curRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(balance &lt;- <span class="number">1</span> &amp;&amp; newNode-&gt;value &lt; curRoot-&gt;right-&gt;value) &#123;</span><br><span class="line">        <span class="comment">// Put your code below</span></span><br><span class="line">        curRoot-&gt;right=<span class="built_in">rightRotate</span>(curRoot-&gt;right);</span><br><span class="line">        curRoot=<span class="built_in">leftRotate</span>(curRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h5><ul>
<li>Insert the new key as a new leaf just as in ordinary binary search tree: $O(logN)$;</li>
<li>The trace the path &#x3D;&#x3D;from the new leaf towards the root, for each node x&#x3D;&#x3D; encountered: $O(logN)$;<ul>
<li>Check height difference: $O(1)$;</li>
<li>If satisfies $AVL$ property, proceed to next node: $O(1)$;</li>
<li>If not, perform a rotation: $O(1)$;</li>
</ul>
</li>
<li>The insertion stops when:<ul>
<li>A rotation is performed;</li>
<li>Or, we have checked all nodes in the path.</li>
</ul>
</li>
<li>Time complexity for insertion: $O(logN)$.</li>
</ul>
<p>Here is a gif of insertion:</p>
<p><img src="https://img-blog.csdnimg.cn/740d4ce00f7d4cdb99b687da14f910d8.gif#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-Deletion-in-AVL-tree"><a href="#3-Deletion-in-AVL-tree" class="headerlink" title="3. Deletion in $AVL$ tree"></a>3. Deletion in $AVL$ tree</h3><ul>
<li>Delete a node x as in ordinary binary search tree<ul>
<li>Note that the last (deepest) node in a tree deleted is a &#x3D;&#x3D;leaf&#x3D;&#x3D; or &#x3D;&#x3D;a node with one child&#x3D;&#x3D;</li>
</ul>
</li>
<li>Then trace the path from &#x3D;&#x3D;the new leaf towards the root&#x3D;&#x3D;;</li>
<li>For each node x encountered, check if heights of left(x), and right(x) differ by at most 1.<ul>
<li>If &#x3D;&#x3D;no&#x3D;&#x3D;, perform an appropriate rotation at x;</li>
<li>If &#x3D;&#x3D;yes&#x3D;&#x3D;, proceed to parent(x);</li>
<li>&#x3D;&#x3D;Continue to trace the path until we reach the root.&#x3D;&#x3D;<br><img src="https://img-blog.csdnimg.cn/8246e55970ff4fd7a943ad2c82a8e9fc.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/898b43fb7f884a63a04946a19aa8a5f0.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/df392e00475746148f34c667b2907130.png#pic_center" alt="在这里插入图片描述"></p>
<p>And here is a code in text book:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">( <span class="type">const</span> Comparable &amp; x, AvlNode * &amp; t )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( t == <span class="literal">nullptr</span> )</span><br><span class="line">           <span class="keyword">return</span>;   <span class="comment">// Item not found; do nothing</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>( x &lt; t-&gt;element )</span><br><span class="line">           <span class="built_in">remove</span>( x, t-&gt;left );</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>( t-&gt;element &lt; x )</span><br><span class="line">           <span class="built_in">remove</span>( x, t-&gt;right );</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>( t-&gt;left != <span class="literal">nullptr</span> &amp;&amp; t-&gt;right != <span class="literal">nullptr</span> ) <span class="comment">// Two children</span></span><br><span class="line">       &#123;</span><br><span class="line">           t-&gt;element = <span class="built_in">findMin</span>( t-&gt;right )-&gt;element;</span><br><span class="line">           <span class="built_in">remove</span>( t-&gt;element, t-&gt;right );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           AvlNode *oldNode = t;</span><br><span class="line">           t = ( t-&gt;left != <span class="literal">nullptr</span> ) ? t-&gt;left : t-&gt;right;</span><br><span class="line">           <span class="keyword">delete</span> oldNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">balance</span>( t );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Search-function"><a href="#4-Search-function" class="headerlink" title="4. Search function"></a>4. Search function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Search the TreeNode WITHOUT recursive</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::iterativeSearch</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Put your code below</span></span><br><span class="line">	TreeNode* nownode = root;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (nownode-&gt;value != val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val &lt; nownode-&gt;value) &#123;</span><br><span class="line">			nownode = nownode-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			nownode = nownode-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nownode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nownode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Search the TreeNode WITH recursive</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">AVLTree::recursiveSearch</span><span class="params">(TreeNode* curRoot, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Put your code below</span></span><br><span class="line">	<span class="keyword">if</span> (curRoot == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; curRoot-&gt;value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recursiveSearch</span>(curRoot-&gt;left, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; curRoot-&gt;value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recursiveSearch</span>(curRoot-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> curRoot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-B-Tree"><a href="#6-3-B-Tree" class="headerlink" title="6.3 B+ Tree"></a>6.3 B+ Tree</h2><p>在B+树中，我们不要求用代码实现出来，但是我们要知道它的实现过程是怎么样的。</p>
<p><img src="https://img-blog.csdnimg.cn/1bb5f8d75f444a15904675c7fd2325bb.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a9a1b4723dc345a7999f08ca1425687d.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e6d498823c0a4400b25f643cadc22458.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>M-ary Search Tree<ul>
<li>Binary search tree has one key to decide which of  the two branches to take;</li>
<li>M-ary search tree needs &#x3D;&#x3D;M-1 keys to decide which  branch to take&#x3D;&#x3D;;</li>
<li>M-ary search tree &#x3D;&#x3D;should be balanced in some  way too&#x3D;&#x3D;;<ul>
<li>We don’t want an M-ary search tree to degenerate to a  linked list, or even a binary search tree;</li>
<li>Thus, require that each node is at least ½ full !</li>
</ul>
</li>
<li>一棵$M叉查找树$(M-ary search tree)，可以有M路分支，随着分支增加，树的深度在减少。一棵完全二叉树的高度大约有$log_2N,$ 而一棵完全M叉树的高度大约为$log_MN$.</li>
</ul>
</li>
</ul>
<h3 id="1-Property"><a href="#1-Property" class="headerlink" title="1. Property"></a>1. Property</h3><p>A B+ tree of order $M(M&gt;3)$ is an M-ary tree with the following properties:</p>
<ol>
<li><p>The data items are stored at leaves;(数据项存储在树叶上)</p>
</li>
<li><p>The nonleaf nodes store up to $M − 1$ keys to guide the searching; key $i$ represents the smallest key in subtree $i + 1$;（非叶子节点存储到$M-1$个关键字以指示搜索的方向；关键字$i$代表子树$i+1$中的最小的关键字）</p>
</li>
<li><p>The root is either a leaf or has between two and $M$ children;(树的根或者是一片树叶，或者其儿子树在2和M之间)</p>
</li>
<li><p>All nonleaf nodes (except the root) have between $\lceil  M&#x2F;2\rceil$ and $M$ &#x3D;&#x3D;children&#x3D;&#x3D;;（除根外，所有非叶子节点的&#x3D;&#x3D;儿子数&#x3D;&#x3D;在 $\lceil  M&#x2F;2\rceil$ and $M$ 之间）</p>
</li>
<li><p>All leaves are at the same depth and have between $\lceil L&#x2F;2\rceil$ and $L$ &#x3D;&#x3D;data items&#x3D;&#x3D;, for some $L$ (the determination of $L$ is described shortly).（所有的树叶都在相同的深度上，并且每片树叶拥有的数据项其个数在$\lceil L&#x2F;2\rceil$ and $L$ 之间）</p>
<p>&#x3D;&#x3D;（$\lceil x\rceil$表示对x向上取整）&#x3D;&#x3D;</p>
<p>注意，4,5点两个一个focus on子树的个数，另一个则是数据项（key）的个数</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/536ca0989d07474391f4e32380d9a595.png#pic_center" alt="在这里插入图片描述"></p>
<p>   在这个B+树里面，第一行为root，第二行为nonleaf node&#x2F;internal node,第三行为leaf node。</p>
<p>   And:</p>
<ul>
<li>Records are stored at the leaves</li>
<li>Since &#x3D;&#x3D;<strong>L</strong>&#x3D;&#x3D;&#x3D;5, each leaf has between 3 and 5 &#x3D;&#x3D;<strong>data items</strong>&#x3D;&#x3D;</li>
<li>Since &#x3D;&#x3D;<strong>M</strong>&#x3D;&#x3D;&#x3D;5, each nonleaf nodes has between 3 to 5 &#x3D;&#x3D;<strong>children</strong>&#x3D;&#x3D;;</li>
<li>Requiring nodes to be half full guarantees that the B+ tree does not degenerate into a simple binary tree.(要求节点为半满保证了B+树不会退化为简单的二叉树。)<br><img src="https://img-blog.csdnimg.cn/55d2589d66c049b99b67adf4d003a7b0.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/747bd9282a334b19b06f851f456a86fd.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h3 id="2-Algorithm"><a href="#2-Algorithm" class="headerlink" title="2. Algorithm"></a>2. Algorithm</h3><h4 id="1-Searching-Algorithm"><a href="#1-Searching-Algorithm" class="headerlink" title="1. Searching Algorithm"></a>1. Searching Algorithm</h4><ul>
<li>Let x be the input search key;</li>
<li>Start the searching at the root;</li>
<li>If we encounter an internal node v, search (linear search  or binary search) for x among the keys stored at v;<ul>
<li>If $x &lt; K_{min}$ at v, follow the left child pointer of $K_{min}$;</li>
<li>If $K_i ≤ x &lt; K_{i+1}$ for two consecutive keys $K_i$ and $K_{i+1}$ at $v$, follow  the left child pointer of $K_{i+1}$;</li>
<li>If $x ≥ K_{max}$ at $v$, follow the right child pointer of $K_{max}$</li>
</ul>
</li>
<li>If we encounter a leaf v, we search (linear search or  binary search) for x among the keys stored at v. If found,  we return the entire record; otherwise, report not found.</li>
</ul>
<h4 id="2-Insertion-Algorithm"><a href="#2-Insertion-Algorithm" class="headerlink" title="2. Insertion Algorithm"></a>2. Insertion Algorithm</h4><p>Supposed that we want to insert a key K and its associated record. First we should do is determine the location where it will be inserted. By search algorithm, which will bring us to a leaf x, then if the leaf is not full, we can directly insert the K, but what if it is already full?</p>
<p>Here is another crucial property of B+ tree: &#x3D;&#x3D;<strong>Splitting</strong>&#x3D;&#x3D;, both insertion and deletion you will meet it. </p>
<p>Keeping going:</p>
<ul>
<li>If leaf x contains &lt; L keys, then insert K into x (at the  correct position in node x);</li>
<li>If x is already full (i.e. containing L keys). <strong>Split</strong> x:<ul>
<li>Cut x off from its parent;</li>
<li>Insert K into x, pretending x has space for K. Now x has L+1 keys.</li>
<li>After inserting K, split x into 2 new leaves $x_L ,and, x_R$, with $x_L$ containing the $\lfloor(L+1)&#x2F;2 \rfloor$ smallest keys, and $x_R$ containing the  remaining $\lceil (L+1)&#x2F;2\rceil$ keys. Let J be the minimum key in $x_R$;</li>
<li>Make a copy of $J$ to be the parent of $x_L$ and $x_R$, and insert the copy  together with its child pointers into the old parent of $x$;</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/cc340985b9be4820b695b4986de094b8.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/52652fed48db4b62ba7552498d5a03f1.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d371a3c57f7b400ba280b9bb0ddcf25d.png#pic_center" alt="在这里插入图片描述"><br>But here just the situation of leaf node split if we keep doing insertion, actually the internal node will finally full. Next I will show you how to split the internal node:</p>
<ul>
<li>Cut x off from its parent;</li>
<li>Insert K and its left and right child pointers into x,  pretending there is space. Now x has M keys;</li>
<li>Split x into 2 new internal nodes $x_L$ and $x_R$, with $x_L$ containing the ( $\lceil M&#x2F;2\rceil - 1$ ) smallest keys, and $x_R$ containing the $\lfloor M&#x2F;2\rfloor$ largest keys. Note that the ($\lceil M&#x2F;2\rceil$)th  key J is not placed in $x_L$ or $x_R$;</li>
<li>Make $J$ the parent of $x_L$ and $x_R$, and insert J together with  its child pointers into the old parent of x.</li>
</ul>
<p>​	<br><img src="https://img-blog.csdnimg.cn/1cee78d6d95443e9b0dc16f85d1cd4c7.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a68ff462ad1947c9a6a788b2f5510e72.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/85313a17241b44cbbfb064c20460fdef.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="3-Deletion-Algorithm"><a href="#3-Deletion-Algorithm" class="headerlink" title="3. Deletion Algorithm"></a>3. Deletion Algorithm</h4><p>Same like the insertion, there are also two situations you have to take consideration.</p>
<ul>
<li>(1) target is a key in some internal node (needs to be  replaced, according to our convention)</li>
<li>(2) After deleting target from leaf x, x contains less than  $\lceil L&#x2F;2\rceil$ keys (needs to merge nodes)</li>
</ul>
<p>(这里面的target应该指的是internal node 里面的key值)</p>
<p>Target can appear in at most one ancestor y of x  as a key, Node y is seen when we searched down the tree. After deleting from node x, we can access y  directly and replace target by the new smallest  key in x.</p>
<p>Suppose we delete the record with key target from a leaf. Let u be the leaf that has $\lceil L&#x2F;2\rceil - 1$ keys (too few); Let v be a sibling of u with at least $\lceil L&#x2F;2\rceil+1$ keys; Let k be the key in the parent of u and v that  separates the pointers to u and v;There are two cases:</p>
<ul>
<li><p>Case 1: v contains $\lceil L&#x2F;2\rceil+1$ or more keys and v is the right sibling of u;</p>
<ul>
<li>Move the leftmost record from v to u</li>
</ul>
</li>
<li><p>Case 2: v contain $\lceil L&#x2F;2\rceil+1$ or more keys and v is the left sibling of u;</p>
<ul>
<li>Move the rightmost record from v to u</li>
</ul>
</li>
<li><p>Then set the key in parent of u that separates    u and v to be the new smallest key in u;</p>
<p>(就是说，如果左叶子（右叶子）的key不满足前面我们提到的property的话，如果右叶子（左叶子）在满足property的下限还多的话，我们可以从中借一个或几个，或者直接merge掉两个叶子节点)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d4909037737e4c788cc7f1f8b8a0b5f3.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b1c4801958824926afd295a055a0329b.png#pic_center" alt="在这里插入图片描述"></p>
<p>  前面我们提到了merge，下面我们来讲讲merge的情况：</p>
<p>  If no sibling leaaf with $\lceil L&#x2F;2\rceil+1$ or more keys exits, then merge two leaves.</p>
<ul>
<li><p>Case 1: Suppose that the &#x3D;&#x3D;right sibling&#x3D;&#x3D; v of u contains exactly $\lceil L&#x2F;2\rceil$ keys. Merge u and v:</p>
<ul>
<li>Move the keys in u to v;</li>
<li>Remove the pointer to u at parent;</li>
<li>Delete the separating key between u and v from the parent of u.</li>
</ul>
</li>
<li><p>Case 2: Suppose that the &#x3D;&#x3D;left sibling&#x3D;&#x3D; v of u contains exactly $\lceil L&#x2F;2\rceil$ keys. Merge u and v :</p>
<ul>
<li><p>Move the keys in u to v;</p>
</li>
<li><p>Remove the pointer to u at parent;</p>
</li>
<li><p>Delete the separating key between u and v from the parent of u.<br><img src="https://img-blog.csdnimg.cn/23c0916e5a9d48c284ea33c373b27ff3.png#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/e315c2e032b1481e82ec45f37423580f.png#pic_center" alt="在这里插入图片描述"></p>
<p>But if when we update the key value in the internal node:</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4f230dd7d5974ed393b4a80dd7c262f6.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>Then the internal node doesn’t fit the property of B+ tree, so what should we do?</p>
<p><strong>Deleting a key in an internal node</strong>:</p>
<p>Suppose we remove a key from an internal node u, and u has less than $\lceil M&#x2F;2\rceil-1$ keys after that:</p>
<ul>
<li><p>Case 1: u is a root</p>
<ul>
<li>Thus u has only one child, then we remove u and make its child the new root;</li>
</ul>
</li>
<li><p>Case 2A: the right sibling v of u has $\lceil M&#x2F;2\rceil$ keys or more:</p>
<ul>
<li>Move the separating key between u and v in the parent of u  and v down to u;</li>
<li>Move the leftmost key in v to become the separating key between u and v in the parent of u and v;</li>
<li>Make the leftmost child of v the rightmost child of u.</li>
</ul>
</li>
<li><p>Case 2B:  the left sibling v of u has $\lceil M&#x2F;2\rceil$ keys or more:</p>
<ul>
<li>Move the separating key between u and v in the parent of u  and v down to u;</li>
<li>Move the rightmost key in v to become the separating key between u and v in the parent of u and v;</li>
<li>Make the rightmost child of v the leftmost child of u.</li>
</ul>
</li>
<li><p>Case study: Case 2A:</p>
</li>
<li><p><img src="https://img-blog.csdnimg.cn/d88c1ed664b34dd3becf64ca220c3a30.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/aaff13996bf54141a71b8d00c74ed4a1.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>Case 3: All sibling v of u contains exactly $\lceil M&#x2F;2\rceil-1$ keys:</p>
<ul>
<li>Move the separating key between u and v in the  parent of u and v down to v;</li>
<li>Move the keys and child pointers in u to v;</li>
<li>Remove the pointer to u at parent.<br><img src="https://img-blog.csdnimg.cn/4b49b503850a467992a9efa615a64e0e.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2417e7af30414b3fa08846aafdb5b443.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/feb51d62c79b471db3001cbb8e40a711.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/42702abedc9f4696afc895897ff5418d.gif#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h2 id="7-Graph"><a href="#7-Graph" class="headerlink" title="7. Graph"></a>7. Graph</h2><p>Consist of : vertex(节点)，Edge(边)</p>
<p>Vertex can be considered “sites” or locations;</p>
<p>Edge represents connection.</p>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul>
<li>A graph G(V,E) consists a set of vertices, V, and a set of edges, E.</li>
<li>Each edge is a pair of (v,w), where v, w belongs to V;</li>
<li>If the pair is unordered, the graph is undirected(无向的); otherwise it is directed(有向的)</li>
<li>Terminology:<ul>
<li>If $v_1$ and $v_2$ are connected, they are said to be &#x3D;&#x3D;adjacent&#x3D;&#x3D; vertices<ul>
<li>$v_1,and,v_2$ are endpoints of the edge {$v_1,v_2$}.</li>
</ul>
</li>
<li>If an edge e is connected to v, then v is said to be  incident on e. Also, the edge e is said to be incident on  v;</li>
<li>For undirected graph: {$v_1,v_2$}&#x3D;{$v_2,v_1$};</li>
<li>For directed graph: they are not equal to each other.<br><img src="https://img-blog.csdnimg.cn/73080f5884ae49689c457ce4c4932c46.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0202feaa9e194956ae61f78be48d9335.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/62cda73382a74c0ebbc8d5cc3211f17b.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/a42100ce326b4f38b41d2727bee4c28f.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b49980c9f88c4ec0bce38d33dfc6fd4c.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<p>(我们无法在$O(1)$的时间里check两个节点是否相连)</p>
<ul>
<li>Adjacency List：<ul>
<li>More compact than adjacency matrices if graph has few edges;</li>
<li>Requires more time to find if an edge exists;</li>
</ul>
</li>
<li>Adjacency Matrix:<ul>
<li>Always require $n^2$ space;<ul>
<li>This can waste a lot of space if the graph is sparse(稀少的)；</li>
</ul>
</li>
<li>Can quickly find if an edge exists.</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/75b2af0efba34629a9a3e4dd7b1c1cc2.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ce51bbb586384d4daa4516ee2e99a172.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>The code of adjacency list</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="comment">// Create pointer point to an array of list</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; *l;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">        V = size;</span><br><span class="line">        l = <span class="keyword">new</span> list&lt;<span class="type">int</span>&gt; [V]; <span class="comment">// [V] is the array contain V number of list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">bool</span>  undir=<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">        l[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(undir)&#123;</span><br><span class="line">            l[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all the rows</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">// every element of ith linked list</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> node:l[i])&#123;</span><br><span class="line">                cout &lt;&lt; node &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">printAdjList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Graph-Traversal"><a href="#Graph-Traversal" class="headerlink" title="Graph Traversal"></a>Graph Traversal</h3><p>Example: Given a graph representation and a vertex s in the  graph, find all paths from s to other vertices.</p>
<p>Two common graph traversal algorithms</p>
<ul>
<li>Breadth First Search ($BFS$)<ul>
<li>Find all paths from s to other vertices;</li>
</ul>
</li>
<li>Depth First Search ($DFS$)<ul>
<li>Topological sort;</li>
<li>Find strongly connected components.</li>
</ul>
</li>
</ul>
<h3 id="1-BFS-Algorithm-广度优先算法"><a href="#1-BFS-Algorithm-广度优先算法" class="headerlink" title="1. $BFS$ Algorithm 广度优先算法"></a>1. $BFS$ Algorithm 广度优先算法</h3><h4 id="1-Pseudocode"><a href="#1-Pseudocode" class="headerlink" title="1. Pseudocode"></a>1. Pseudocode</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Algorothm BFS</span><br><span class="line">Input: s is the source vertex</span><br><span class="line">Output: Mark all vertices that can be visited from s.</span><br><span class="line"><span class="number">1.</span>	<span class="keyword">for</span> wach vertex v</span><br><span class="line"><span class="number">2.</span>		<span class="keyword">do</span> flag[v]:=<span class="literal">false</span>; <span class="comment">//flag[]:visited table</span></span><br><span class="line"><span class="number">3.</span>	Q=empty queue;<span class="comment">//use queue: FIFO</span></span><br><span class="line"><span class="number">4.</span>	flag[s]:=<span class="literal">true</span>;</span><br><span class="line"><span class="number">5.</span>	<span class="built_in">enqueue</span>(Q,s);</span><br><span class="line"><span class="number">6.</span>	<span class="keyword">while</span> Q is <span class="keyword">not</span> empty</span><br><span class="line"><span class="number">7.</span>		<span class="keyword">do</span> v:=<span class="built_in">dequeue</span>(Q);</span><br><span class="line"><span class="number">8.</span>			<span class="keyword">for</span> each w adjancent v</span><br><span class="line"><span class="number">9.</span>				<span class="keyword">do</span> <span class="keyword">if</span> flag[w]=<span class="literal">false</span></span><br><span class="line"><span class="number">10.</span>					then flag[w]:=<span class="literal">true</span>;</span><br><span class="line"><span class="number">11.</span>						<span class="built_in">enqueue</span>(Q,w)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f4a1dcbed8fb43aeaaa5175a0caefc6a.gif#pic_center" alt="在这里插入图片描述"></p>
<p>在上图中，source vertex为2，我们就先遍历它的所有adjacencies，我们看到下面的Q，就是为了方便我们标记哪一个已经被traverse过了，比如source vertex为2，我们就先把2 enqueue 到Q中，接着dequeue出来，并在visited table标记他已经被访问过了，然后把2的adjacencies enqueue到Q中，然后再重复操作。每一次dequeue一个vertex，就要把它的没有被标记过visited的adjacencies enqueue进Q中，直到所有的vertex都被标记为visited。</p>
<ul>
<li>Analysis:<ul>
<li>The line 6 of pseudocode: Each vertex will enter Q at most once;</li>
<li>The line 8 of pseudocode: Each iteration takes time  proportional to deg(v) + 1 (the  number 1 is to account for the  case where deg(v) &#x3D; 0 — the  work required is 1, not 0).（在这里我是没看懂这个+1的解释的，我更倾向于把这个+1理解为代表dequeue）</li>
<li>Then running time of <strong>adjacent list</strong>: $T(n)&#x3D;O(\sum_{vertex,v}^{}(deg(v)+1))&#x3D;O(n+2m)&#x3D;O(n+m)$ This is summing over all the iterations in the while loop</li>
<li>But for the adjacent matrix it will spend $O(n^2)$.</li>
</ul>
</li>
</ul>
<p>So, with <strong>adjacency matrix</strong>, $BFS$ is $O(n^2)$  <strong>independent</strong> of the number of <strong>edges</strong> m.  With <strong>adjacent lists</strong>, $BFS$ is $O(n+m)$; if  $m&#x3D;O(n^2)$ like in a <strong>dense graph</strong>,  $O(n+m)&#x3D;O(n^2)$.</p>
<h4 id="2-Shortest-Path-Recording"><a href="#2-Shortest-Path-Recording" class="headerlink" title="2. Shortest Path Recording"></a>2. Shortest Path Recording</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Algorothm BFS</span><br><span class="line">Input: s is the source vertex</span><br><span class="line">Output: Mark all vertices that can be visited from s.</span><br><span class="line"><span class="number">1.</span>	<span class="keyword">for</span> wach vertex v</span><br><span class="line"><span class="number">2.</span>		<span class="keyword">do</span> flag[v]:=<span class="literal">false</span>; <span class="comment">//flag[]:visited table</span></span><br><span class="line"><span class="number">3.</span>		   pred[v]:=<span class="number">-1</span>;<span class="comment">//initializa all pred[v]to -1(this array is to help you record the previous vertex)</span></span><br><span class="line"><span class="number">4.</span>	Q=empty queue;<span class="comment">//use queue: FIFO</span></span><br><span class="line"><span class="number">5.</span>	flag[s]:=<span class="literal">true</span>;</span><br><span class="line"><span class="number">6.</span>	<span class="built_in">enqueue</span>(Q,s);</span><br><span class="line"><span class="number">7.</span>	<span class="keyword">while</span> Q is <span class="keyword">not</span> empty</span><br><span class="line"><span class="number">8.</span>		<span class="keyword">do</span> v:=<span class="built_in">dequeue</span>(Q);</span><br><span class="line"><span class="number">9.</span>			<span class="keyword">for</span> each w adjancent v</span><br><span class="line"><span class="number">10.</span>				<span class="keyword">do</span> <span class="keyword">if</span> flag[w]=<span class="literal">false</span></span><br><span class="line"><span class="number">11.</span>					then flag[w]:=<span class="literal">true</span>;</span><br><span class="line"><span class="number">12.</span>						 pred[w]:=v;<span class="comment">//record where you came from</span></span><br><span class="line"><span class="number">13.</span>					     <span class="built_in">enqueue</span>(Q,w)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7b270ac026e64b419cef1aa456ccf591.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>Path report:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Algorithm <span class="title">Path</span><span class="params">(w)</span></span></span><br><span class="line"><span class="function">1.	<span class="keyword">if</span> pred[w]!</span>=<span class="number">-1</span></span><br><span class="line"><span class="number">2.</span>		then</span><br><span class="line"><span class="number">3.</span>			<span class="built_in">Parh</span>(pred[w]);</span><br><span class="line"><span class="number">4.</span>	uutput w</span><br></pre></td></tr></table></figure>

<p>The path returned is the shortest from s to v(minimum number of edges).</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/3b90b0e36f694c6d8b547d72d6fafa4a.png" alt="请添加图片描述"></p>
<ul>
<li><p>Record the Shortest distance</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Algorothm BFS</span><br><span class="line">Input: s is the source vertex</span><br><span class="line">Output: Mark all vertices that can be visited from s.</span><br><span class="line"><span class="number">1.</span>	<span class="keyword">for</span> wach vertex v</span><br><span class="line"><span class="number">2.</span>		<span class="keyword">do</span> flag[v]:=<span class="literal">false</span>; <span class="comment">//flag[]:visited table</span></span><br><span class="line"><span class="number">3.</span>		   pred[v]:=<span class="number">-1</span>;<span class="built_in">d</span>(v)=MAX_INT;<span class="comment">//initializa all pred[v]to -1(this array is to help you record the previous vertex)</span></span><br><span class="line"><span class="number">4.</span>	Q=empty queue;<span class="comment">//use queue: FIFO</span></span><br><span class="line"><span class="number">5.</span>	flag[s]:=<span class="literal">true</span>;<span class="built_in">d</span>(s)=<span class="number">0</span>;</span><br><span class="line"><span class="number">6.</span>	<span class="built_in">enqueue</span>(Q,s);</span><br><span class="line"><span class="number">7.</span>	<span class="keyword">while</span> Q is <span class="keyword">not</span> empty</span><br><span class="line"><span class="number">8.</span>		<span class="keyword">do</span> v:=<span class="built_in">dequeue</span>(Q);</span><br><span class="line"><span class="number">9.</span>			<span class="keyword">for</span> each w adjancent v</span><br><span class="line"><span class="number">10.</span>				<span class="keyword">do</span> <span class="keyword">if</span> flag[w]=<span class="literal">false</span></span><br><span class="line"><span class="number">11.</span>					then flag[w]:=<span class="literal">true</span>;</span><br><span class="line"><span class="number">12.</span>				  <span class="built_in">d</span>(w)=<span class="built_in">d</span>(v)+<span class="number">1</span>;pred[w]:=v;<span class="comment">//record where you came from</span></span><br><span class="line"><span class="number">13.</span>					     <span class="built_in">enqueue</span>(Q,w)</span><br></pre></td></tr></table></figure>

<p><strong>Code of $BFS$</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Graph Traversals: BFS (Breadth First Search) Queue */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="comment">// Create pointer point to an array of list</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; *l;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">        V = size;</span><br><span class="line">        l = <span class="keyword">new</span> list&lt;<span class="type">int</span>&gt; [V]; <span class="comment">// [V] is the array contain V number of list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">bool</span>  undir=<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">        l[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(undir)&#123;</span><br><span class="line">            l[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all the rows</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">// every element of ith linked list</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> node:l[i])&#123;</span><br><span class="line">                cout &lt;&lt; node &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> source)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Create queue</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">bool</span> *visited = <span class="keyword">new</span> <span class="type">bool</span> [V]&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(source);</span><br><span class="line">        visited[source] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// Do some work for every node</span></span><br><span class="line">            <span class="type">int</span> f = q.<span class="built_in">front</span>();</span><br><span class="line">            cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push the nbrs of current node inside q if they are not already visited</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> nbr : l[f])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[nbr])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(nbr);</span><br><span class="line">                    visited[nbr] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span> - <span class="number">1</span>, <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span> - <span class="number">1</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span> - <span class="number">1</span>, <span class="number">4</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span> - <span class="number">1</span>, <span class="number">5</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span> - <span class="number">1</span>, <span class="number">6</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span> - <span class="number">1</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span> - <span class="number">1</span>, <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span> - <span class="number">1</span>, <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span> - <span class="number">1</span>, <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">6</span> - <span class="number">1</span>, <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">6</span> - <span class="number">1</span>, <span class="number">7</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span> - <span class="number">1</span>, <span class="number">6</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span> - <span class="number">1</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span> - <span class="number">1</span>, <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">8</span> - <span class="number">1</span>, <span class="number">5</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">8</span> - <span class="number">1</span>, <span class="number">7</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span> - <span class="number">1</span>, <span class="number">1</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span> - <span class="number">1</span>, <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span> - <span class="number">1</span>, <span class="number">7</span> - <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">bfs</span>(<span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">printAdjList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-DFS-Depth-First-Search"><a href="#2-DFS-Depth-First-Search" class="headerlink" title="2. $DFS$ Depth First Search"></a>2. $DFS$ Depth First Search</h3><ul>
<li>$DFS$ is another popular graph search strategy;<ul>
<li>Idea is similar to pre-order traversal (visit node, then  visit children recursively);</li>
</ul>
</li>
<li>$DFS$ can provide certain information about the  graph that $BFS$ cannot;<ul>
<li>It can tell whether we have encountered a cycle or not.</li>
</ul>
</li>
<li><strong>深度优先算法</strong>是对先序遍历(preorder traversal)的推广。</li>
<li>$DFS$ will continue to visit neighbors in a recursive  pattern:<ul>
<li>Whenever we visit v from u, we recursively visit all  unvisited neighbors of v. Then we backtrack (return) to  u.</li>
<li>这里面一开始的递归访问v的所有unvisited neighbors并不像$BFS$那样先把v的所有neighbors都加入到queue里面，而是另外的意思，稍后会解释。</li>
</ul>
</li>
</ul>
<p>$DFS$ Algorithm：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Algorithm <span class="title">DFS</span><span class="params">(s)</span></span></span><br><span class="line"><span class="function">1.	<span class="keyword">for</span> each vertex v</span></span><br><span class="line"><span class="function">2.		<span class="keyword">do</span> flag[v]:=</span><span class="literal">false</span>;<span class="comment">//Flag all vertices as not visited</span></span><br><span class="line"><span class="number">3.</span>	RDFS;</span><br><span class="line"></span><br><span class="line"><span class="function">Algorithm <span class="title">RDFS</span><span class="params">(v)</span></span></span><br><span class="line"><span class="function">1.	flag[v]:=</span><span class="literal">true</span>;<span class="comment">//Flag yourself as visited</span></span><br><span class="line"><span class="number">2.</span>	<span class="keyword">for</span> each neighbor w of v<span class="comment">//For unvisited neighbors call RDFS(w) recursively</span></span><br><span class="line"><span class="number">3.</span>		<span class="keyword">do</span> <span class="keyword">if</span> flag[w]=<span class="literal">false</span></span><br><span class="line"><span class="number">4.</span>			then <span class="built_in">RDFS</span>(w);</span><br><span class="line"></span><br><span class="line"><span class="comment">//We can also record the paths using pred[]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/d049a2a27eb643db95e11e3855a423e4.gif" alt="请添加图片描述"></p>
<p>这么理解递归的意思：从source开始，一条路走到黑，然后返回到上一个，如果上一个的neighbors也都标记了，继续return，如果return到没有被标记的，那就走那条路然后一条路走到黑。如果都被标记了，那就return回source vertex。<br><img src="https://img-blog.csdnimg.cn/fdc55b3a39e34275b378250ab9ed71a6.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/efa150b417b34b218e001d4dfd3d4f94.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Graph Traversals: DFS (Depth First Search) Stack */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="comment">// Create pointer point to an array of list</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; *l;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> size)&#123;</span><br><span class="line">        V = size;</span><br><span class="line">        l = <span class="keyword">new</span> list&lt;<span class="type">int</span>&gt; [V]; <span class="comment">// [V] is the array contain V number of list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">bool</span>  undir=<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line">        l[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(undir)&#123;</span><br><span class="line">            l[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAdjList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Iterate over all the rows</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)&#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            <span class="comment">// every element of ith linked list</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> node:l[i])&#123;</span><br><span class="line">                cout &lt;&lt; node &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsHelper</span><span class="params">(<span class="type">int</span> node, <span class="type">bool</span> *visited)</span></span>&#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; node &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make a dfs call on all unvisited neighbours</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> nbr : l[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[nbr])&#123;</span><br><span class="line">                <span class="built_in">dfsHelper</span>(nbr, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> source)</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> *visited = <span class="keyword">new</span> <span class="type">bool</span> [V]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">dfsHelper</span>(source, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span><span class="number">-1</span>,<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span><span class="number">-1</span>,<span class="number">9</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span><span class="number">-1</span>,<span class="number">1</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span><span class="number">-1</span>,<span class="number">4</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span><span class="number">-1</span>,<span class="number">5</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span><span class="number">-1</span>,<span class="number">6</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span><span class="number">-1</span>,<span class="number">9</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span><span class="number">-1</span>,<span class="number">3</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span><span class="number">-1</span>,<span class="number">3</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span><span class="number">-1</span>,<span class="number">8</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">6</span><span class="number">-1</span>,<span class="number">3</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">6</span><span class="number">-1</span>,<span class="number">7</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span><span class="number">-1</span>,<span class="number">6</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span><span class="number">-1</span>,<span class="number">9</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">7</span><span class="number">-1</span>,<span class="number">8</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">8</span><span class="number">-1</span>,<span class="number">5</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">8</span><span class="number">-1</span>,<span class="number">7</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span><span class="number">-1</span>,<span class="number">1</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span><span class="number">-1</span>,<span class="number">3</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">9</span><span class="number">-1</span>,<span class="number">7</span><span class="number">-1</span>);</span><br><span class="line">    g.<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">printAdjList</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里多讲一嘴：for(auto a:b)</p>
<ul>
<li>这里面可以简单将b看做一个array，但是其实适用于各种容器；</li>
<li>a的话相当于一个接收变量来接收b中的值，每一次迭代，a都代表了b中的一个变量<ul>
<li>比如说：for(auto a:b&#x3D;[1,2,3,4]){cout&lt;&lt;a;}那么每一次循环中a的值分别为：1,2,3,4</li>
</ul>
</li>
</ul>
<p>	</p>
<h2 id="8-Reference"><a href="#8-Reference" class="headerlink" title="8. Reference"></a>8. Reference</h2><p><em><strong>Data Structures and Algorithm Analysis in C++</strong></em></p>
<p>The lecture slides</p>
<p>Information from Internet  </p>
</div><div class="tags"></div><div class="post-nav"><a class="next" href="/2022/07/23/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://example.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/07/23/Data%20Structure/">Data Structure</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/23/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Rick2pc.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>